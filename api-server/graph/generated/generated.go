// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/pluralsh/oauth-playground/api-server/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Group() GroupResolver
	LoginBindings() LoginBindingsResolver
	Mutation() MutationResolver
	OAuth2Client() OAuth2ClientResolver
	ObservabilityTenant() ObservabilityTenantResolver
	ObservabilityTenantEditors() ObservabilityTenantEditorsResolver
	ObservabilityTenantViewers() ObservabilityTenantViewersResolver
	Organization() OrganizationResolver
	Query() QueryResolver
	User() UserResolver
}

type DirectiveRoot struct {
	CheckPermissions func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	IsAuthenticated  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Group struct {
		Members      func(childComplexity int) int
		Name         func(childComplexity int) int
		Organization func(childComplexity int) int
	}

	LoginBindings struct {
		Groups func(childComplexity int) int
		Users  func(childComplexity int) int
	}

	Mutation struct {
		AcceptOAuth2ConsentRequest func(childComplexity int, challenge string, grantAccessTokenAudience *string, grantScope []string, remember *bool, rememberFor *int64, session *model.AcceptOAuth2ConsentRequestSession) int
		CreateOAuth2Client         func(childComplexity int, allowedCorsOrigins []string, audience []string, authorizationCodeGrantAccessTokenLifespan *string, authorizationCodeGrantIDTokenLifespan *string, authorizationCodeGrantRefreshTokenLifespan *string, backChannelLogoutSessionRequired *bool, backChannelLogoutURI *string, clientCredentialsGrantAccessTokenLifespan *string, clientName *string, clientSecret *string, clientSecretExpiresAt *int64, clientURI *string, contacts []string, frontchannelLogoutSessionRequired *bool, frontchannelLogoutURI *string, grantTypes []string, implicitGrantAccessTokenLifespan *string, implicitGrantIDTokenLifespan *string, jwks map[string]interface{}, jwksURI *string, jwtBearerGrantAccessTokenLifespan *string, logoURI *string, metadata map[string]interface{}, policyURI *string, postLogoutRedirectUris []string, redirectUris []string, responseTypes []string, scope *string, sectorIdentifierURI *string, subjectType *string, tokenEndpointAuthMethod *string, tokenEndpointAuthSigningAlgorithm *string, tosURI *string, userinfoSignedResponseAlgorithm *string, loginBindings *model.LoginBindingsInput) int
		CreateUser                 func(childComplexity int, email string, name *model.NameInput) int
		DeleteGroup                func(childComplexity int, name string) int
		DeleteOAuth2Client         func(childComplexity int, clientID string) int
		DeleteObservabilityTenant  func(childComplexity int, name string) int
		DeleteUser                 func(childComplexity int, id string) int
		Group                      func(childComplexity int, name string, members []string) int
		ObservabilityTenant        func(childComplexity int, name string, viewers *model.ObservabilityTenantViewersInput, editors *model.ObservabilityTenantEditorsInput) int
		Organization               func(childComplexity int, name string, admins []string) int
		RejectOAuth2ConsentRequest func(childComplexity int, challenge string) int
		UpdateOAuth2Client         func(childComplexity int, allowedCorsOrigins []string, audience []string, authorizationCodeGrantAccessTokenLifespan *string, authorizationCodeGrantIDTokenLifespan *string, authorizationCodeGrantRefreshTokenLifespan *string, backChannelLogoutSessionRequired *bool, backChannelLogoutURI *string, clientCredentialsGrantAccessTokenLifespan *string, clientID string, clientName *string, clientSecret *string, clientSecretExpiresAt *int64, clientURI *string, contacts []string, frontchannelLogoutSessionRequired *bool, frontchannelLogoutURI *string, grantTypes []string, implicitGrantAccessTokenLifespan *string, implicitGrantIDTokenLifespan *string, jwks map[string]interface{}, jwksURI *string, jwtBearerGrantAccessTokenLifespan *string, logoURI *string, metadata map[string]interface{}, policyURI *string, postLogoutRedirectUris []string, redirectUris []string, responseTypes []string, scope *string, sectorIdentifierURI *string, subjectType *string, tokenEndpointAuthMethod *string, tokenEndpointAuthSigningAlgorithm *string, tosURI *string, userinfoSignedResponseAlgorithm *string, loginBindings *model.LoginBindingsInput) int
	}

	Name struct {
		First func(childComplexity int) int
		Last  func(childComplexity int) int
	}

	OAuth2Client struct {
		AllowedCorsOrigins                         func(childComplexity int) int
		Audience                                   func(childComplexity int) int
		AuthorizationCodeGrantAccessTokenLifespan  func(childComplexity int) int
		AuthorizationCodeGrantIDTokenLifespan      func(childComplexity int) int
		AuthorizationCodeGrantRefreshTokenLifespan func(childComplexity int) int
		BackChannelLogoutSessionRequired           func(childComplexity int) int
		BackChannelLogoutURI                       func(childComplexity int) int
		ClientCredentialsGrantAccessTokenLifespan  func(childComplexity int) int
		ClientID                                   func(childComplexity int) int
		ClientName                                 func(childComplexity int) int
		ClientSecret                               func(childComplexity int) int
		ClientSecretExpiresAt                      func(childComplexity int) int
		ClientURI                                  func(childComplexity int) int
		Contacts                                   func(childComplexity int) int
		CreatedAt                                  func(childComplexity int) int
		FrontchannelLogoutSessionRequired          func(childComplexity int) int
		FrontchannelLogoutURI                      func(childComplexity int) int
		GrantTypes                                 func(childComplexity int) int
		ImplicitGrantAccessTokenLifespan           func(childComplexity int) int
		ImplicitGrantIDTokenLifespan               func(childComplexity int) int
		Jwks                                       func(childComplexity int) int
		JwksURI                                    func(childComplexity int) int
		JwtBearerGrantAccessTokenLifespan          func(childComplexity int) int
		LoginBindings                              func(childComplexity int) int
		LogoURI                                    func(childComplexity int) int
		Metadata                                   func(childComplexity int) int
		Organization                               func(childComplexity int) int
		Owner                                      func(childComplexity int) int
		PolicyURI                                  func(childComplexity int) int
		PostLogoutRedirectUris                     func(childComplexity int) int
		RedirectUris                               func(childComplexity int) int
		ResponseTypes                              func(childComplexity int) int
		Scope                                      func(childComplexity int) int
		SectorIdentifierURI                        func(childComplexity int) int
		SubjectType                                func(childComplexity int) int
		TokenEndpointAuthMethod                    func(childComplexity int) int
		TokenEndpointAuthSigningAlgorithm          func(childComplexity int) int
		TosURI                                     func(childComplexity int) int
		UpdatedAt                                  func(childComplexity int) int
		UserinfoSignedResponseAlgorithm            func(childComplexity int) int
	}

	OAuth2ConsentRequest struct {
		Acr                          func(childComplexity int) int
		Amr                          func(childComplexity int) int
		Challenge                    func(childComplexity int) int
		Client                       func(childComplexity int) int
		Context                      func(childComplexity int) int
		LoginChallenge               func(childComplexity int) int
		LoginSessionID               func(childComplexity int) int
		OidcContext                  func(childComplexity int) int
		RequestURL                   func(childComplexity int) int
		RequestedAccessTokenAudience func(childComplexity int) int
		RequestedScope               func(childComplexity int) int
		Skip                         func(childComplexity int) int
		Subject                      func(childComplexity int) int
	}

	OAuth2RedirectTo struct {
		RedirectTo func(childComplexity int) int
	}

	ObservabilityTenant struct {
		Editors      func(childComplexity int) int
		Name         func(childComplexity int) int
		Organization func(childComplexity int) int
		Viewers      func(childComplexity int) int
	}

	ObservabilityTenantEditors struct {
		Groups func(childComplexity int) int
		Users  func(childComplexity int) int
	}

	ObservabilityTenantViewers struct {
		Groups        func(childComplexity int) int
		Oauth2Clients func(childComplexity int) int
		Users         func(childComplexity int) int
	}

	OidcContext struct {
		AcrValues         func(childComplexity int) int
		Display           func(childComplexity int) int
		IDTokenHintClaims func(childComplexity int) int
		LoginHint         func(childComplexity int) int
		UILocales         func(childComplexity int) int
	}

	Organization struct {
		Admins func(childComplexity int) int
		Name   func(childComplexity int) int
	}

	Query struct {
		GetOAuth2Client          func(childComplexity int, clientID string) int
		GetObservabilityTenant   func(childComplexity int, name string) int
		GetUser                  func(childComplexity int, id string) int
		ListGroups               func(childComplexity int) int
		ListOAuth2Clients        func(childComplexity int) int
		ListObservabilityTenants func(childComplexity int) int
		ListOrganizations        func(childComplexity int) int
		ListUsers                func(childComplexity int) int
		Oauth2ConsentRequest     func(childComplexity int, challenge string) int
	}

	User struct {
		Email        func(childComplexity int) int
		Groups       func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Organization func(childComplexity int) int
		RecoveryLink func(childComplexity int) int
	}
}

type GroupResolver interface {
	Members(ctx context.Context, obj *model.Group) ([]*model.User, error)
}
type LoginBindingsResolver interface {
	Users(ctx context.Context, obj *model.LoginBindings) ([]*model.User, error)
	Groups(ctx context.Context, obj *model.LoginBindings) ([]*model.Group, error)
}
type MutationResolver interface {
	CreateUser(ctx context.Context, email string, name *model.NameInput) (*model.User, error)
	DeleteUser(ctx context.Context, id string) (*model.User, error)
	Group(ctx context.Context, name string, members []string) (*model.Group, error)
	DeleteGroup(ctx context.Context, name string) (*model.Group, error)
	CreateOAuth2Client(ctx context.Context, allowedCorsOrigins []string, audience []string, authorizationCodeGrantAccessTokenLifespan *string, authorizationCodeGrantIDTokenLifespan *string, authorizationCodeGrantRefreshTokenLifespan *string, backChannelLogoutSessionRequired *bool, backChannelLogoutURI *string, clientCredentialsGrantAccessTokenLifespan *string, clientName *string, clientSecret *string, clientSecretExpiresAt *int64, clientURI *string, contacts []string, frontchannelLogoutSessionRequired *bool, frontchannelLogoutURI *string, grantTypes []string, implicitGrantAccessTokenLifespan *string, implicitGrantIDTokenLifespan *string, jwks map[string]interface{}, jwksURI *string, jwtBearerGrantAccessTokenLifespan *string, logoURI *string, metadata map[string]interface{}, policyURI *string, postLogoutRedirectUris []string, redirectUris []string, responseTypes []string, scope *string, sectorIdentifierURI *string, subjectType *string, tokenEndpointAuthMethod *string, tokenEndpointAuthSigningAlgorithm *string, tosURI *string, userinfoSignedResponseAlgorithm *string, loginBindings *model.LoginBindingsInput) (*model.OAuth2Client, error)
	UpdateOAuth2Client(ctx context.Context, allowedCorsOrigins []string, audience []string, authorizationCodeGrantAccessTokenLifespan *string, authorizationCodeGrantIDTokenLifespan *string, authorizationCodeGrantRefreshTokenLifespan *string, backChannelLogoutSessionRequired *bool, backChannelLogoutURI *string, clientCredentialsGrantAccessTokenLifespan *string, clientID string, clientName *string, clientSecret *string, clientSecretExpiresAt *int64, clientURI *string, contacts []string, frontchannelLogoutSessionRequired *bool, frontchannelLogoutURI *string, grantTypes []string, implicitGrantAccessTokenLifespan *string, implicitGrantIDTokenLifespan *string, jwks map[string]interface{}, jwksURI *string, jwtBearerGrantAccessTokenLifespan *string, logoURI *string, metadata map[string]interface{}, policyURI *string, postLogoutRedirectUris []string, redirectUris []string, responseTypes []string, scope *string, sectorIdentifierURI *string, subjectType *string, tokenEndpointAuthMethod *string, tokenEndpointAuthSigningAlgorithm *string, tosURI *string, userinfoSignedResponseAlgorithm *string, loginBindings *model.LoginBindingsInput) (*model.OAuth2Client, error)
	DeleteOAuth2Client(ctx context.Context, clientID string) (*model.OAuth2Client, error)
	AcceptOAuth2ConsentRequest(ctx context.Context, challenge string, grantAccessTokenAudience *string, grantScope []string, remember *bool, rememberFor *int64, session *model.AcceptOAuth2ConsentRequestSession) (*model.OAuth2RedirectTo, error)
	RejectOAuth2ConsentRequest(ctx context.Context, challenge string) (*model.OAuth2RedirectTo, error)
	ObservabilityTenant(ctx context.Context, name string, viewers *model.ObservabilityTenantViewersInput, editors *model.ObservabilityTenantEditorsInput) (*model.ObservabilityTenant, error)
	DeleteObservabilityTenant(ctx context.Context, name string) (*model.ObservabilityTenant, error)
	Organization(ctx context.Context, name string, admins []string) (*model.Organization, error)
}
type OAuth2ClientResolver interface {
	Owner(ctx context.Context, obj *model.OAuth2Client) (*string, error)

	LoginBindings(ctx context.Context, obj *model.OAuth2Client) (*model.LoginBindings, error)
}
type ObservabilityTenantResolver interface {
	Viewers(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantViewers, error)
	Editors(ctx context.Context, obj *model.ObservabilityTenant) (*model.ObservabilityTenantEditors, error)
}
type ObservabilityTenantEditorsResolver interface {
	Users(ctx context.Context, obj *model.ObservabilityTenantEditors) ([]*model.User, error)
	Groups(ctx context.Context, obj *model.ObservabilityTenantEditors) ([]*model.Group, error)
}
type ObservabilityTenantViewersResolver interface {
	Users(ctx context.Context, obj *model.ObservabilityTenantViewers) ([]*model.User, error)
	Groups(ctx context.Context, obj *model.ObservabilityTenantViewers) ([]*model.Group, error)
	Oauth2Clients(ctx context.Context, obj *model.ObservabilityTenantViewers) ([]*model.OAuth2Client, error)
}
type OrganizationResolver interface {
	Admins(ctx context.Context, obj *model.Organization) ([]*model.User, error)
}
type QueryResolver interface {
	ListUsers(ctx context.Context) ([]*model.User, error)
	GetUser(ctx context.Context, id string) (*model.User, error)
	ListGroups(ctx context.Context) ([]*model.Group, error)
	ListOAuth2Clients(ctx context.Context) ([]*model.OAuth2Client, error)
	GetOAuth2Client(ctx context.Context, clientID string) (*model.OAuth2Client, error)
	Oauth2ConsentRequest(ctx context.Context, challenge string) (*model.OAuth2ConsentRequest, error)
	ListObservabilityTenants(ctx context.Context) ([]*model.ObservabilityTenant, error)
	GetObservabilityTenant(ctx context.Context, name string) (*model.ObservabilityTenant, error)
	ListOrganizations(ctx context.Context) ([]*model.Organization, error)
}
type UserResolver interface {
	Groups(ctx context.Context, obj *model.User) ([]*model.Group, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Group.members":
		if e.complexity.Group.Members == nil {
			break
		}

		return e.complexity.Group.Members(childComplexity), true

	case "Group.name":
		if e.complexity.Group.Name == nil {
			break
		}

		return e.complexity.Group.Name(childComplexity), true

	case "Group.organization":
		if e.complexity.Group.Organization == nil {
			break
		}

		return e.complexity.Group.Organization(childComplexity), true

	case "LoginBindings.groups":
		if e.complexity.LoginBindings.Groups == nil {
			break
		}

		return e.complexity.LoginBindings.Groups(childComplexity), true

	case "LoginBindings.users":
		if e.complexity.LoginBindings.Users == nil {
			break
		}

		return e.complexity.LoginBindings.Users(childComplexity), true

	case "Mutation.acceptOAuth2ConsentRequest":
		if e.complexity.Mutation.AcceptOAuth2ConsentRequest == nil {
			break
		}

		args, err := ec.field_Mutation_acceptOAuth2ConsentRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AcceptOAuth2ConsentRequest(childComplexity, args["challenge"].(string), args["grantAccessTokenAudience"].(*string), args["grantScope"].([]string), args["remember"].(*bool), args["rememberFor"].(*int64), args["session"].(*model.AcceptOAuth2ConsentRequestSession)), true

	case "Mutation.createOAuth2Client":
		if e.complexity.Mutation.CreateOAuth2Client == nil {
			break
		}

		args, err := ec.field_Mutation_createOAuth2Client_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOAuth2Client(childComplexity, args["allowedCorsOrigins"].([]string), args["audience"].([]string), args["authorizationCodeGrantAccessTokenLifespan"].(*string), args["authorizationCodeGrantIdTokenLifespan"].(*string), args["authorizationCodeGrantRefreshTokenLifespan"].(*string), args["backChannelLogoutSessionRequired"].(*bool), args["backChannelLogoutUri"].(*string), args["clientCredentialsGrantAccessTokenLifespan"].(*string), args["clientName"].(*string), args["clientSecret"].(*string), args["ClientSecretExpiresAt"].(*int64), args["clientUri"].(*string), args["contacts"].([]string), args["frontchannelLogoutSessionRequired"].(*bool), args["frontchannelLogoutUri"].(*string), args["grantTypes"].([]string), args["implicitGrantAccessTokenLifespan"].(*string), args["implicitGrantIdTokenLifespan"].(*string), args["jwks"].(map[string]interface{}), args["jwksUri"].(*string), args["jwtBearerGrantAccessTokenLifespan"].(*string), args["logoUri"].(*string), args["metadata"].(map[string]interface{}), args["policyUri"].(*string), args["postLogoutRedirectUris"].([]string), args["redirectUris"].([]string), args["responseTypes"].([]string), args["scope"].(*string), args["sectorIdentifierUri"].(*string), args["subjectType"].(*string), args["tokenEndpointAuthMethod"].(*string), args["tokenEndpointAuthSigningAlgorithm"].(*string), args["tosUri"].(*string), args["userinfoSignedResponseAlgorithm"].(*string), args["loginBindings"].(*model.LoginBindingsInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["email"].(string), args["name"].(*model.NameInput)), true

	case "Mutation.deleteGroup":
		if e.complexity.Mutation.DeleteGroup == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGroup_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGroup(childComplexity, args["name"].(string)), true

	case "Mutation.deleteOAuth2Client":
		if e.complexity.Mutation.DeleteOAuth2Client == nil {
			break
		}

		args, err := ec.field_Mutation_deleteOAuth2Client_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteOAuth2Client(childComplexity, args["clientId"].(string)), true

	case "Mutation.deleteObservabilityTenant":
		if e.complexity.Mutation.DeleteObservabilityTenant == nil {
			break
		}

		args, err := ec.field_Mutation_deleteObservabilityTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteObservabilityTenant(childComplexity, args["name"].(string)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["id"].(string)), true

	case "Mutation.group":
		if e.complexity.Mutation.Group == nil {
			break
		}

		args, err := ec.field_Mutation_group_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Group(childComplexity, args["name"].(string), args["members"].([]string)), true

	case "Mutation.observabilityTenant":
		if e.complexity.Mutation.ObservabilityTenant == nil {
			break
		}

		args, err := ec.field_Mutation_observabilityTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ObservabilityTenant(childComplexity, args["name"].(string), args["viewers"].(*model.ObservabilityTenantViewersInput), args["editors"].(*model.ObservabilityTenantEditorsInput)), true

	case "Mutation.organization":
		if e.complexity.Mutation.Organization == nil {
			break
		}

		args, err := ec.field_Mutation_organization_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Organization(childComplexity, args["name"].(string), args["admins"].([]string)), true

	case "Mutation.rejectOAuth2ConsentRequest":
		if e.complexity.Mutation.RejectOAuth2ConsentRequest == nil {
			break
		}

		args, err := ec.field_Mutation_rejectOAuth2ConsentRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RejectOAuth2ConsentRequest(childComplexity, args["challenge"].(string)), true

	case "Mutation.updateOAuth2Client":
		if e.complexity.Mutation.UpdateOAuth2Client == nil {
			break
		}

		args, err := ec.field_Mutation_updateOAuth2Client_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOAuth2Client(childComplexity, args["allowedCorsOrigins"].([]string), args["audience"].([]string), args["authorizationCodeGrantAccessTokenLifespan"].(*string), args["authorizationCodeGrantIdTokenLifespan"].(*string), args["authorizationCodeGrantRefreshTokenLifespan"].(*string), args["backChannelLogoutSessionRequired"].(*bool), args["backChannelLogoutUri"].(*string), args["clientCredentialsGrantAccessTokenLifespan"].(*string), args["clientId"].(string), args["clientName"].(*string), args["clientSecret"].(*string), args["ClientSecretExpiresAt"].(*int64), args["clientUri"].(*string), args["contacts"].([]string), args["frontchannelLogoutSessionRequired"].(*bool), args["frontchannelLogoutUri"].(*string), args["grantTypes"].([]string), args["implicitGrantAccessTokenLifespan"].(*string), args["implicitGrantIdTokenLifespan"].(*string), args["jwks"].(map[string]interface{}), args["jwksUri"].(*string), args["jwtBearerGrantAccessTokenLifespan"].(*string), args["logoUri"].(*string), args["metadata"].(map[string]interface{}), args["policyUri"].(*string), args["postLogoutRedirectUris"].([]string), args["redirectUris"].([]string), args["responseTypes"].([]string), args["scope"].(*string), args["sectorIdentifierUri"].(*string), args["subjectType"].(*string), args["tokenEndpointAuthMethod"].(*string), args["tokenEndpointAuthSigningAlgorithm"].(*string), args["tosUri"].(*string), args["userinfoSignedResponseAlgorithm"].(*string), args["loginBindings"].(*model.LoginBindingsInput)), true

	case "Name.first":
		if e.complexity.Name.First == nil {
			break
		}

		return e.complexity.Name.First(childComplexity), true

	case "Name.last":
		if e.complexity.Name.Last == nil {
			break
		}

		return e.complexity.Name.Last(childComplexity), true

	case "OAuth2Client.allowedCorsOrigins":
		if e.complexity.OAuth2Client.AllowedCorsOrigins == nil {
			break
		}

		return e.complexity.OAuth2Client.AllowedCorsOrigins(childComplexity), true

	case "OAuth2Client.audience":
		if e.complexity.OAuth2Client.Audience == nil {
			break
		}

		return e.complexity.OAuth2Client.Audience(childComplexity), true

	case "OAuth2Client.authorizationCodeGrantAccessTokenLifespan":
		if e.complexity.OAuth2Client.AuthorizationCodeGrantAccessTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.AuthorizationCodeGrantAccessTokenLifespan(childComplexity), true

	case "OAuth2Client.authorizationCodeGrantIdTokenLifespan":
		if e.complexity.OAuth2Client.AuthorizationCodeGrantIDTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.AuthorizationCodeGrantIDTokenLifespan(childComplexity), true

	case "OAuth2Client.authorizationCodeGrantRefreshTokenLifespan":
		if e.complexity.OAuth2Client.AuthorizationCodeGrantRefreshTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.AuthorizationCodeGrantRefreshTokenLifespan(childComplexity), true

	case "OAuth2Client.backChannelLogoutSessionRequired":
		if e.complexity.OAuth2Client.BackChannelLogoutSessionRequired == nil {
			break
		}

		return e.complexity.OAuth2Client.BackChannelLogoutSessionRequired(childComplexity), true

	case "OAuth2Client.backChannelLogoutUri":
		if e.complexity.OAuth2Client.BackChannelLogoutURI == nil {
			break
		}

		return e.complexity.OAuth2Client.BackChannelLogoutURI(childComplexity), true

	case "OAuth2Client.clientCredentialsGrantAccessTokenLifespan":
		if e.complexity.OAuth2Client.ClientCredentialsGrantAccessTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientCredentialsGrantAccessTokenLifespan(childComplexity), true

	case "OAuth2Client.clientId":
		if e.complexity.OAuth2Client.ClientID == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientID(childComplexity), true

	case "OAuth2Client.clientName":
		if e.complexity.OAuth2Client.ClientName == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientName(childComplexity), true

	case "OAuth2Client.clientSecret":
		if e.complexity.OAuth2Client.ClientSecret == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientSecret(childComplexity), true

	case "OAuth2Client.ClientSecretExpiresAt":
		if e.complexity.OAuth2Client.ClientSecretExpiresAt == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientSecretExpiresAt(childComplexity), true

	case "OAuth2Client.clientUri":
		if e.complexity.OAuth2Client.ClientURI == nil {
			break
		}

		return e.complexity.OAuth2Client.ClientURI(childComplexity), true

	case "OAuth2Client.contacts":
		if e.complexity.OAuth2Client.Contacts == nil {
			break
		}

		return e.complexity.OAuth2Client.Contacts(childComplexity), true

	case "OAuth2Client.createdAt":
		if e.complexity.OAuth2Client.CreatedAt == nil {
			break
		}

		return e.complexity.OAuth2Client.CreatedAt(childComplexity), true

	case "OAuth2Client.frontchannelLogoutSessionRequired":
		if e.complexity.OAuth2Client.FrontchannelLogoutSessionRequired == nil {
			break
		}

		return e.complexity.OAuth2Client.FrontchannelLogoutSessionRequired(childComplexity), true

	case "OAuth2Client.frontchannelLogoutUri":
		if e.complexity.OAuth2Client.FrontchannelLogoutURI == nil {
			break
		}

		return e.complexity.OAuth2Client.FrontchannelLogoutURI(childComplexity), true

	case "OAuth2Client.grantTypes":
		if e.complexity.OAuth2Client.GrantTypes == nil {
			break
		}

		return e.complexity.OAuth2Client.GrantTypes(childComplexity), true

	case "OAuth2Client.implicitGrantAccessTokenLifespan":
		if e.complexity.OAuth2Client.ImplicitGrantAccessTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.ImplicitGrantAccessTokenLifespan(childComplexity), true

	case "OAuth2Client.implicitGrantIdTokenLifespan":
		if e.complexity.OAuth2Client.ImplicitGrantIDTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.ImplicitGrantIDTokenLifespan(childComplexity), true

	case "OAuth2Client.jwks":
		if e.complexity.OAuth2Client.Jwks == nil {
			break
		}

		return e.complexity.OAuth2Client.Jwks(childComplexity), true

	case "OAuth2Client.jwksUri":
		if e.complexity.OAuth2Client.JwksURI == nil {
			break
		}

		return e.complexity.OAuth2Client.JwksURI(childComplexity), true

	case "OAuth2Client.jwtBearerGrantAccessTokenLifespan":
		if e.complexity.OAuth2Client.JwtBearerGrantAccessTokenLifespan == nil {
			break
		}

		return e.complexity.OAuth2Client.JwtBearerGrantAccessTokenLifespan(childComplexity), true

	case "OAuth2Client.loginBindings":
		if e.complexity.OAuth2Client.LoginBindings == nil {
			break
		}

		return e.complexity.OAuth2Client.LoginBindings(childComplexity), true

	case "OAuth2Client.logoUri":
		if e.complexity.OAuth2Client.LogoURI == nil {
			break
		}

		return e.complexity.OAuth2Client.LogoURI(childComplexity), true

	case "OAuth2Client.metadata":
		if e.complexity.OAuth2Client.Metadata == nil {
			break
		}

		return e.complexity.OAuth2Client.Metadata(childComplexity), true

	case "OAuth2Client.organization":
		if e.complexity.OAuth2Client.Organization == nil {
			break
		}

		return e.complexity.OAuth2Client.Organization(childComplexity), true

	case "OAuth2Client.owner":
		if e.complexity.OAuth2Client.Owner == nil {
			break
		}

		return e.complexity.OAuth2Client.Owner(childComplexity), true

	case "OAuth2Client.policyUri":
		if e.complexity.OAuth2Client.PolicyURI == nil {
			break
		}

		return e.complexity.OAuth2Client.PolicyURI(childComplexity), true

	case "OAuth2Client.postLogoutRedirectUris":
		if e.complexity.OAuth2Client.PostLogoutRedirectUris == nil {
			break
		}

		return e.complexity.OAuth2Client.PostLogoutRedirectUris(childComplexity), true

	case "OAuth2Client.redirectUris":
		if e.complexity.OAuth2Client.RedirectUris == nil {
			break
		}

		return e.complexity.OAuth2Client.RedirectUris(childComplexity), true

	case "OAuth2Client.responseTypes":
		if e.complexity.OAuth2Client.ResponseTypes == nil {
			break
		}

		return e.complexity.OAuth2Client.ResponseTypes(childComplexity), true

	case "OAuth2Client.scope":
		if e.complexity.OAuth2Client.Scope == nil {
			break
		}

		return e.complexity.OAuth2Client.Scope(childComplexity), true

	case "OAuth2Client.sectorIdentifierUri":
		if e.complexity.OAuth2Client.SectorIdentifierURI == nil {
			break
		}

		return e.complexity.OAuth2Client.SectorIdentifierURI(childComplexity), true

	case "OAuth2Client.subjectType":
		if e.complexity.OAuth2Client.SubjectType == nil {
			break
		}

		return e.complexity.OAuth2Client.SubjectType(childComplexity), true

	case "OAuth2Client.tokenEndpointAuthMethod":
		if e.complexity.OAuth2Client.TokenEndpointAuthMethod == nil {
			break
		}

		return e.complexity.OAuth2Client.TokenEndpointAuthMethod(childComplexity), true

	case "OAuth2Client.tokenEndpointAuthSigningAlgorithm":
		if e.complexity.OAuth2Client.TokenEndpointAuthSigningAlgorithm == nil {
			break
		}

		return e.complexity.OAuth2Client.TokenEndpointAuthSigningAlgorithm(childComplexity), true

	case "OAuth2Client.tosUri":
		if e.complexity.OAuth2Client.TosURI == nil {
			break
		}

		return e.complexity.OAuth2Client.TosURI(childComplexity), true

	case "OAuth2Client.updatedAt":
		if e.complexity.OAuth2Client.UpdatedAt == nil {
			break
		}

		return e.complexity.OAuth2Client.UpdatedAt(childComplexity), true

	case "OAuth2Client.userinfoSignedResponseAlgorithm":
		if e.complexity.OAuth2Client.UserinfoSignedResponseAlgorithm == nil {
			break
		}

		return e.complexity.OAuth2Client.UserinfoSignedResponseAlgorithm(childComplexity), true

	case "OAuth2ConsentRequest.acr":
		if e.complexity.OAuth2ConsentRequest.Acr == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Acr(childComplexity), true

	case "OAuth2ConsentRequest.amr":
		if e.complexity.OAuth2ConsentRequest.Amr == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Amr(childComplexity), true

	case "OAuth2ConsentRequest.challenge":
		if e.complexity.OAuth2ConsentRequest.Challenge == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Challenge(childComplexity), true

	case "OAuth2ConsentRequest.client":
		if e.complexity.OAuth2ConsentRequest.Client == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Client(childComplexity), true

	case "OAuth2ConsentRequest.context":
		if e.complexity.OAuth2ConsentRequest.Context == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Context(childComplexity), true

	case "OAuth2ConsentRequest.loginChallenge":
		if e.complexity.OAuth2ConsentRequest.LoginChallenge == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.LoginChallenge(childComplexity), true

	case "OAuth2ConsentRequest.loginSessionId":
		if e.complexity.OAuth2ConsentRequest.LoginSessionID == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.LoginSessionID(childComplexity), true

	case "OAuth2ConsentRequest.oidcContext":
		if e.complexity.OAuth2ConsentRequest.OidcContext == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.OidcContext(childComplexity), true

	case "OAuth2ConsentRequest.requestUrl":
		if e.complexity.OAuth2ConsentRequest.RequestURL == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.RequestURL(childComplexity), true

	case "OAuth2ConsentRequest.requestedAccessTokenAudience":
		if e.complexity.OAuth2ConsentRequest.RequestedAccessTokenAudience == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.RequestedAccessTokenAudience(childComplexity), true

	case "OAuth2ConsentRequest.requestedScope":
		if e.complexity.OAuth2ConsentRequest.RequestedScope == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.RequestedScope(childComplexity), true

	case "OAuth2ConsentRequest.skip":
		if e.complexity.OAuth2ConsentRequest.Skip == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Skip(childComplexity), true

	case "OAuth2ConsentRequest.subject":
		if e.complexity.OAuth2ConsentRequest.Subject == nil {
			break
		}

		return e.complexity.OAuth2ConsentRequest.Subject(childComplexity), true

	case "OAuth2RedirectTo.redirectTo":
		if e.complexity.OAuth2RedirectTo.RedirectTo == nil {
			break
		}

		return e.complexity.OAuth2RedirectTo.RedirectTo(childComplexity), true

	case "ObservabilityTenant.editors":
		if e.complexity.ObservabilityTenant.Editors == nil {
			break
		}

		return e.complexity.ObservabilityTenant.Editors(childComplexity), true

	case "ObservabilityTenant.name":
		if e.complexity.ObservabilityTenant.Name == nil {
			break
		}

		return e.complexity.ObservabilityTenant.Name(childComplexity), true

	case "ObservabilityTenant.organization":
		if e.complexity.ObservabilityTenant.Organization == nil {
			break
		}

		return e.complexity.ObservabilityTenant.Organization(childComplexity), true

	case "ObservabilityTenant.viewers":
		if e.complexity.ObservabilityTenant.Viewers == nil {
			break
		}

		return e.complexity.ObservabilityTenant.Viewers(childComplexity), true

	case "ObservabilityTenantEditors.groups":
		if e.complexity.ObservabilityTenantEditors.Groups == nil {
			break
		}

		return e.complexity.ObservabilityTenantEditors.Groups(childComplexity), true

	case "ObservabilityTenantEditors.users":
		if e.complexity.ObservabilityTenantEditors.Users == nil {
			break
		}

		return e.complexity.ObservabilityTenantEditors.Users(childComplexity), true

	case "ObservabilityTenantViewers.groups":
		if e.complexity.ObservabilityTenantViewers.Groups == nil {
			break
		}

		return e.complexity.ObservabilityTenantViewers.Groups(childComplexity), true

	case "ObservabilityTenantViewers.oauth2Clients":
		if e.complexity.ObservabilityTenantViewers.Oauth2Clients == nil {
			break
		}

		return e.complexity.ObservabilityTenantViewers.Oauth2Clients(childComplexity), true

	case "ObservabilityTenantViewers.users":
		if e.complexity.ObservabilityTenantViewers.Users == nil {
			break
		}

		return e.complexity.ObservabilityTenantViewers.Users(childComplexity), true

	case "OidcContext.acrValues":
		if e.complexity.OidcContext.AcrValues == nil {
			break
		}

		return e.complexity.OidcContext.AcrValues(childComplexity), true

	case "OidcContext.display":
		if e.complexity.OidcContext.Display == nil {
			break
		}

		return e.complexity.OidcContext.Display(childComplexity), true

	case "OidcContext.idTokenHintClaims":
		if e.complexity.OidcContext.IDTokenHintClaims == nil {
			break
		}

		return e.complexity.OidcContext.IDTokenHintClaims(childComplexity), true

	case "OidcContext.loginHint":
		if e.complexity.OidcContext.LoginHint == nil {
			break
		}

		return e.complexity.OidcContext.LoginHint(childComplexity), true

	case "OidcContext.uiLocales":
		if e.complexity.OidcContext.UILocales == nil {
			break
		}

		return e.complexity.OidcContext.UILocales(childComplexity), true

	case "Organization.admins":
		if e.complexity.Organization.Admins == nil {
			break
		}

		return e.complexity.Organization.Admins(childComplexity), true

	case "Organization.name":
		if e.complexity.Organization.Name == nil {
			break
		}

		return e.complexity.Organization.Name(childComplexity), true

	case "Query.getOAuth2Client":
		if e.complexity.Query.GetOAuth2Client == nil {
			break
		}

		args, err := ec.field_Query_getOAuth2Client_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetOAuth2Client(childComplexity, args["clientId"].(string)), true

	case "Query.getObservabilityTenant":
		if e.complexity.Query.GetObservabilityTenant == nil {
			break
		}

		args, err := ec.field_Query_getObservabilityTenant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetObservabilityTenant(childComplexity, args["name"].(string)), true

	case "Query.getUser":
		if e.complexity.Query.GetUser == nil {
			break
		}

		args, err := ec.field_Query_getUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUser(childComplexity, args["id"].(string)), true

	case "Query.listGroups":
		if e.complexity.Query.ListGroups == nil {
			break
		}

		return e.complexity.Query.ListGroups(childComplexity), true

	case "Query.listOAuth2Clients":
		if e.complexity.Query.ListOAuth2Clients == nil {
			break
		}

		return e.complexity.Query.ListOAuth2Clients(childComplexity), true

	case "Query.listObservabilityTenants":
		if e.complexity.Query.ListObservabilityTenants == nil {
			break
		}

		return e.complexity.Query.ListObservabilityTenants(childComplexity), true

	case "Query.listOrganizations":
		if e.complexity.Query.ListOrganizations == nil {
			break
		}

		return e.complexity.Query.ListOrganizations(childComplexity), true

	case "Query.listUsers":
		if e.complexity.Query.ListUsers == nil {
			break
		}

		return e.complexity.Query.ListUsers(childComplexity), true

	case "Query.oauth2ConsentRequest":
		if e.complexity.Query.Oauth2ConsentRequest == nil {
			break
		}

		args, err := ec.field_Query_oauth2ConsentRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Oauth2ConsentRequest(childComplexity, args["challenge"].(string)), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.groups":
		if e.complexity.User.Groups == nil {
			break
		}

		return e.complexity.User.Groups(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.organization":
		if e.complexity.User.Organization == nil {
			break
		}

		return e.complexity.User.Organization(childComplexity), true

	case "User.recoveryLink":
		if e.complexity.User.RecoveryLink == nil {
			break
		}

		return e.complexity.User.RecoveryLink(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAcceptOAuth2ConsentRequestSession,
		ec.unmarshalInputAdmin,
		ec.unmarshalInputLoginBindingsInput,
		ec.unmarshalInputNameInput,
		ec.unmarshalInputObservabilityTenantEditorsInput,
		ec.unmarshalInputObservabilityTenantViewersInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._queryMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error) {
				return ec._Query(ctx, rc.Operation.SelectionSet), nil
			})
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._mutationMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error) {
				return ec._Mutation(ctx, rc.Operation.SelectionSet), nil
			})
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../directives.graphqls", Input: `#check if the user is authenticated or not
directive @isAuthenticated on QUERY | MUTATION | FIELD | FIELD_DEFINITION

#checks user permissions using Keto
directive @checkPermissions on QUERY | MUTATION | FIELD | FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../group.graphqls", Input: `"Representation a group of users."
type Group {
  "The unique name of the group."
  name: String!

  "The users that are admins of the organization."
  members: [User!]

  "The organization that the group belongs to."
  organization: Organization!
}

extend type Query {
  "Get a list of all users."
  listGroups: [Group!] @checkPermissions @isAuthenticated
}

extend type Mutation {
  "Create or update a group."
  group(
    "The unique name of the group."
    name: String!

    "The IDs of the users that are members of the group."
    members: [String!]
  ): Group! @checkPermissions @isAuthenticated

  "Delete a group."
  deleteGroup(
    "The unique name of the group."
    name: String!
  ): Group! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
	{Name: "../oauth2client.graphqls", Input: `scalar Time
scalar Map

"Representation of the information about an OAuth2 Client sourced from Hydra."
type OAuth2Client {

  "OAuth 2.0 Client Allowed CORS Origins. AllowedCORSOrigins is an array of allowed CORS origins. If the array is empty, the value of the first element is considered valid."
  allowedCorsOrigins: [String!]

  "OAuth 2.0 Client Audience. Audience is an array of URLs that the OAuth 2.0 Client is allowed to request tokens for."
  audience: [String!]

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  authorizationCodeGrantAccessTokenLifespan: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  authorizationCodeGrantIdTokenLifespan: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  authorizationCodeGrantRefreshTokenLifespan: String

  "OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false."
  backChannelLogoutSessionRequired: Boolean

  "OpenID Connect Back-Channel Logout URI. RP URL that will cause the RP to log itself out when sent a Logout Token by the OP."
  backChannelLogoutUri: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  clientCredentialsGrantAccessTokenLifespan: String

  "OAuth 2.0 Client ID. The ID is autogenerated and immutable."
  clientId: String

  "OAuth 2.0 Client Name. The human-readable name of the client to be presented to the end-user during authorization."
  clientName: String

  "OAuth 2.0 Client Secret. The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost."
  clientSecret: String

  "OAuth 2.0 Client Secret Expires At. The field is currently not supported and its value is always 0."
  ClientSecretExpiresAt: Int

  "OAuth 2.0 Client URI. ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion."
  clientUri: String

  "OAuth 2.0 Client Contacts. Contacts is an array of strings representing ways to contact people responsible for this client, typically email addresses."
  contacts: [String!]

  "OAuth 2.0 Client Creation Date. CreatedAt returns the timestamp of the client's creation."
  createdAt: Time

  "OpenID Connect Front-Channel Logout Session Required. Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false."
  frontchannelLogoutSessionRequired: Boolean

  "OpenID Connect Front-Channel Logout URI. RP URL that will cause the RP to log itself out when rendered in an iframe by the OP."
  frontchannelLogoutUri: String

  grantTypes: [String!]

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  implicitGrantAccessTokenLifespan: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  implicitGrantIdTokenLifespan: String

  "OAuth 2.0 Client JSON Web Key Set. Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together."
  jwks: Map

  "OAuth 2.0 Client JSON Web Key Set URI. Client's JSON Web Key Set [JWK] document URI, passed by reference. The semantics of the jwks_uri parameter are the same as the jwks parameter, other than that the JWK Set is passed by reference, rather than by value. The jwks_uri and jwks parameters MUST NOT be used together."
  jwksUri: String

  "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
  jwtBearerGrantAccessTokenLifespan: String

  "OAuth 2.0 Client Logo URI. A URL string referencing the client's logo."
  logoUri: String

  "OAuth 2.0 Client Metadata. Metadata is a map of key-value pairs that contain additional information about the client."
  metadata: Map

  "OAuth 2.0 Client Owner. Owner is a string identifying the owner of the OAuth 2.0 Client."
  owner: String

  "OAuth 2.0 Client Policy URI. PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data."
  policyUri: String

  "OAuth 2.0 Client Post Logout Redirect URIs. PostLogoutRedirectUris is an array of allowed URLs to which the RP is allowed to redirect the End-User's User Agent after a logout has been performed."
  postLogoutRedirectUris: [String!]

  "OAuth 2.0 Client Redirect URIs. RedirectUris is an array of allowed redirect URLs for the OAuth 2.0 Client."
  redirectUris: [String!]

  "OAuth 2.0 Client Response Types. ResponseTypes is an array of the OAuth 2.0 response type strings that the client can use at the Authorization Endpoint."
  responseTypes: [String!]

  "OAuth 2.0 Client Scope. Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens."
  scope: String

  "OAuth 2.0 Client Sector Identifier URI. SectorIdentifierURI is a URL string using the https scheme referencing a file with a single JSON array of redirect_uri values."
  sectorIdentifierUri: String

  "OAuth 2.0 Client Subject Type. SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public."
  subjectType: String

  "OAuth 2.0 Client Token Endpoint Auth Method. TokenEndpointAuthMethod is the requested Client Authentication method for the Token Endpoint. The token_endpoint_auth_methods_supported Discovery parameter contains a list of the authentication methods supported by this server. Valid types include client_secret_post, client_secret_basic, private_key_jwt, and none."
  tokenEndpointAuthMethod: String

  "OAuth 2.0 Client Token Endpoint Auth Signing Algorithm. TokenEndpointAuthSigningAlgorithm is the requested Client Authentication signing algorithm for the Token Endpoint. The token_endpoint_auth_signing_alg_values_supported Discovery parameter contains a list of the supported signing algorithms for the token endpoint."
  tokenEndpointAuthSigningAlgorithm: String

  "OAuth 2.0 Client Terms of Service URI. A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client."
  tosUri: String

  "OAuth 2.0 Client Updated Date. UpdatedAt returns the timestamp of the client's last update."
  updatedAt: Time

  "OpenID Connect Userinfo Signed Response Algorithm. UserInfoSignedResponseAlg is a string containing the JWS signing algorithm (alg) parameter required for signing UserInfo Responses. The value none MAY be used, which indicates that the UserInfo Response will not be signed. The alg value RS256 MUST be used unless support for RS256 has been explicitly disabled. If support for RS256 has been disabled, the value none MUST be used."
  userinfoSignedResponseAlgorithm: String

  "The organization that owns this OAuth2 Client."
  organization: Organization!

  "The users and groups that are allowed to login with this OAuth2 Client."
  loginBindings: LoginBindings
}

"Representation of users and groups that are allowed to login with through OAuth2 Client."
type LoginBindings {
  "The users that are allowed to login with this OAuth2 Client."
  users: [User!]

  "The groups that are allowed to login with this OAuth2 Client."
  groups: [Group!]
}

input LoginBindingsInput {
  "The users that are allowed to login with this OAuth2 Client."
  users: [ID!]

  "The groups that are allowed to login with this OAuth2 Client."
  groups: [ID!]
}

extend type Query {
  "Get a list of all OAuth2 Clients."
  listOAuth2Clients: [OAuth2Client!]! @checkPermissions @isAuthenticated

  "Get a single OAuth2 Client by ID."
  getOAuth2Client(
    "The ID of the OAuth2 Client."
    clientId: ID!
  ): OAuth2Client @checkPermissions @isAuthenticated
}

extend type Mutation {
  "Create a new OAuth2 Client."
  createOAuth2Client(
    "OAuth 2.0 Client Allowed CORS Origins. AllowedCORSOrigins is an array of allowed CORS origins. If the array is empty, the value of the first element is considered valid."
    allowedCorsOrigins: [String!]

    "OAuth 2.0 Client Audience. Audience is an array of URLs that the OAuth 2.0 Client is allowed to request tokens for."
    audience: [String!]

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantAccessTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantIdTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantRefreshTokenLifespan: String

    "OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false."
    backChannelLogoutSessionRequired: Boolean

    "OpenID Connect Back-Channel Logout URI. RP URL that will cause the RP to log itself out when sent a Logout Token by the OP."
    backChannelLogoutUri: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    clientCredentialsGrantAccessTokenLifespan: String

    "OAuth 2.0 Client Name. The human-readable name of the client to be presented to the end-user during authorization."
    clientName: String

    "OAuth 2.0 Client Secret. The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost."
    clientSecret: String

    "OAuth 2.0 Client Secret Expires At. The field is currently not supported and its value is always 0."
    ClientSecretExpiresAt: Int

    "OAuth 2.0 Client URI. ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion."
    clientUri: String

    "OAuth 2.0 Client Contacts. Contacts is an array of strings representing ways to contact people responsible for this client, typically email addresses."
    contacts: [String!]

    "OpenID Connect Front-Channel Logout Session Required. Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false."
    frontchannelLogoutSessionRequired: Boolean

    "OpenID Connect Front-Channel Logout URI. RP URL that will cause the RP to log itself out when rendered in an iframe by the OP."
    frontchannelLogoutUri: String

    grantTypes: [String!]

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    implicitGrantAccessTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    implicitGrantIdTokenLifespan: String

    "OAuth 2.0 Client JSON Web Key Set. Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together."
    jwks: Map

    "OAuth 2.0 Client JSON Web Key Set URI. Client's JSON Web Key Set [JWK] document URI, passed by reference. The semantics of the jwks_uri parameter are the same as the jwks parameter, other than that the JWK Set is passed by reference, rather than by value. The jwks_uri and jwks parameters MUST NOT be used together."
    jwksUri: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    jwtBearerGrantAccessTokenLifespan: String

    "OAuth 2.0 Client Logo URI. A URL string referencing the client's logo."
    logoUri: String

    "OAuth 2.0 Client Metadata. Metadata is a map of key-value pairs that contain additional information about the client."
    metadata: Map

    "OAuth 2.0 Client Policy URI. PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data."
    policyUri: String

    "OAuth 2.0 Client Post Logout Redirect URIs. PostLogoutRedirectUris is an array of allowed URLs to which the RP is allowed to redirect the End-User's User Agent after a logout has been performed."
    postLogoutRedirectUris: [String!]

    "OAuth 2.0 Client Redirect URIs. RedirectUris is an array of allowed redirect URLs for the OAuth 2.0 Client."
    redirectUris: [String!]

    "OAuth 2.0 Client Response Types. ResponseTypes is an array of the OAuth 2.0 response type strings that the client can use at the Authorization Endpoint."
    responseTypes: [String!]

    "OAuth 2.0 Client Scope. Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens."
    scope: String

    "OAuth 2.0 Client Sector Identifier URI. SectorIdentifierURI is a URL string using the https scheme referencing a file with a single JSON array of redirect_uri values."
    sectorIdentifierUri: String

    "OAuth 2.0 Client Subject Type. SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public."
    subjectType: String

    "OAuth 2.0 Client Token Endpoint Auth Method. TokenEndpointAuthMethod is the requested Client Authentication method for the Token Endpoint. The token_endpoint_auth_methods_supported Discovery parameter contains a list of the authentication methods supported by this server. Valid types include client_secret_post, client_secret_basic, private_key_jwt, and none."
    tokenEndpointAuthMethod: String

    "OAuth 2.0 Client Token Endpoint Auth Signing Algorithm. TokenEndpointAuthSigningAlgorithm is the requested Client Authentication signing algorithm for the Token Endpoint. The token_endpoint_auth_signing_alg_values_supported Discovery parameter contains a list of the supported signing algorithms for the token endpoint."
    tokenEndpointAuthSigningAlgorithm: String

    "OAuth 2.0 Client Terms of Service URI. A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client."
    tosUri: String

    "OpenID Connect Userinfo Signed Response Algorithm. UserInfoSignedResponseAlg is a string containing the JWS signing algorithm (alg) parameter required for signing UserInfo Responses. The value none MAY be used, which indicates that the UserInfo Response will not be signed. The alg value RS256 MUST be used unless support for RS256 has been explicitly disabled. If support for RS256 has been disabled, the value none MUST be used."
    userinfoSignedResponseAlgorithm: String

    "The users and groups that are allowed to login with this OAuth2 Client."
    loginBindings: LoginBindingsInput
  ): OAuth2Client! @checkPermissions @isAuthenticated

  "Update an OAuth 2 Client."
  updateOAuth2Client(
    "OAuth 2.0 Client Allowed CORS Origins. AllowedCORSOrigins is an array of allowed CORS origins. If the array is empty, the value of the first element is considered valid."
    allowedCorsOrigins: [String!]

    "OAuth 2.0 Client Audience. Audience is an array of URLs that the OAuth 2.0 Client is allowed to request tokens for."
    audience: [String!]

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantAccessTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantIdTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    authorizationCodeGrantRefreshTokenLifespan: String

    "OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false."
    backChannelLogoutSessionRequired: Boolean

    "OpenID Connect Back-Channel Logout URI. RP URL that will cause the RP to log itself out when sent a Logout Token by the OP."
    backChannelLogoutUri: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    clientCredentialsGrantAccessTokenLifespan: String

    "OAuth 2.0 Client ID. The ID is autogenerated and immutable."
    clientId: String!

    "OAuth 2.0 Client Name. The human-readable name of the client to be presented to the end-user during authorization."
    clientName: String

    "OAuth 2.0 Client Secret. The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost."
    clientSecret: String

    "OAuth 2.0 Client Secret Expires At. The field is currently not supported and its value is always 0."
    ClientSecretExpiresAt: Int

    "OAuth 2.0 Client URI. ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion."
    clientUri: String

    "OAuth 2.0 Client Contacts. Contacts is an array of strings representing ways to contact people responsible for this client, typically email addresses."
    contacts: [String!]

    "OpenID Connect Front-Channel Logout Session Required. Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false."
    frontchannelLogoutSessionRequired: Boolean

    "OpenID Connect Front-Channel Logout URI. RP URL that will cause the RP to log itself out when rendered in an iframe by the OP."
    frontchannelLogoutUri: String

    grantTypes: [String!]

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    implicitGrantAccessTokenLifespan: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    implicitGrantIdTokenLifespan: String

    "OAuth 2.0 Client JSON Web Key Set. Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together."
    jwks: Map

    "OAuth 2.0 Client JSON Web Key Set URI. Client's JSON Web Key Set [JWK] document URI, passed by reference. The semantics of the jwks_uri parameter are the same as the jwks parameter, other than that the JWK Set is passed by reference, rather than by value. The jwks_uri and jwks parameters MUST NOT be used together."
    jwksUri: String

    "Specify a time duration in milliseconds, seconds, minutes, hours. For example, 1h, 1m, 1s, 1ms."
    jwtBearerGrantAccessTokenLifespan: String

    "OAuth 2.0 Client Logo URI. A URL string referencing the client's logo."
    logoUri: String

    "OAuth 2.0 Client Metadata. Metadata is a map of key-value pairs that contain additional information about the client."
    metadata: Map

    "OAuth 2.0 Client Policy URI. PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data."
    policyUri: String

    "OAuth 2.0 Client Post Logout Redirect URIs. PostLogoutRedirectUris is an array of allowed URLs to which the RP is allowed to redirect the End-User's User Agent after a logout has been performed."
    postLogoutRedirectUris: [String!]

    "OAuth 2.0 Client Redirect URIs. RedirectUris is an array of allowed redirect URLs for the OAuth 2.0 Client."
    redirectUris: [String!]

    "OAuth 2.0 Client Response Types. ResponseTypes is an array of the OAuth 2.0 response type strings that the client can use at the Authorization Endpoint."
    responseTypes: [String!]

    "OAuth 2.0 Client Scope. Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens."
    scope: String

    "OAuth 2.0 Client Sector Identifier URI. SectorIdentifierURI is a URL string using the https scheme referencing a file with a single JSON array of redirect_uri values."
    sectorIdentifierUri: String

    "OAuth 2.0 Client Subject Type. SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public."
    subjectType: String

    "OAuth 2.0 Client Token Endpoint Auth Method. TokenEndpointAuthMethod is the requested Client Authentication method for the Token Endpoint. The token_endpoint_auth_methods_supported Discovery parameter contains a list of the authentication methods supported by this server. Valid types include client_secret_post, client_secret_basic, private_key_jwt, and none."
    tokenEndpointAuthMethod: String

    "OAuth 2.0 Client Token Endpoint Auth Signing Algorithm. TokenEndpointAuthSigningAlgorithm is the requested Client Authentication signing algorithm for the Token Endpoint. The token_endpoint_auth_signing_alg_values_supported Discovery parameter contains a list of the supported signing algorithms for the token endpoint."
    tokenEndpointAuthSigningAlgorithm: String

    "OAuth 2.0 Client Terms of Service URI. A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client."
    tosUri: String

    "OpenID Connect Userinfo Signed Response Algorithm. UserInfoSignedResponseAlg is a string containing the JWS signing algorithm (alg) parameter required for signing UserInfo Responses. The value none MAY be used, which indicates that the UserInfo Response will not be signed. The alg value RS256 MUST be used unless support for RS256 has been explicitly disabled. If support for RS256 has been disabled, the value none MUST be used."
    userinfoSignedResponseAlgorithm: String

    "The users and groups that are allowed to login with this OAuth2 Client."
    loginBindings: LoginBindingsInput
  ): OAuth2Client! @checkPermissions @isAuthenticated

  "Delete an OAuth2 Client."
  deleteOAuth2Client(
    "OAuth 2.0 Client ID. The ID is autogenerated and immutable."
    clientId: String!
  ): OAuth2Client! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
	{Name: "../oauth2consent.graphqls", Input: `"OAuth2ConsentRequest represents an OAuth 2.0 consent request."
type OAuth2ConsentRequest {
  "ACR represents the Authentication AuthorizationContext Class Reference value for this authentication session. You can use it to express that, for example, a user authenticated using two factor authentication."
  acr: String

  "AMR represents the Authentication Methods References. It lists the method used to authenticate the end-user. For instance, if the end-user authenticated using password and OTP, the AMR value would be [\"pwd\", \"otp\"]."
  amr: [String!]

  "The challenge is a random string which is used to identify the consent request."
  challenge: String!

  "The client is the OAuth 2.0 Client requesting the OAuth 2.0 Authorization."
  client: OAuth2Client!

  "Context contains arbitrary context that is forwarded from the login request. This is useful if you want to pass data from the login request to the consent request."
  context: Map

  "LoginChallenge is the login challenge this consent challenge belongs to. It can be used to associate a login and consent request in the login & consent app."
  loginChallenge: String

  "LoginSessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag) this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false) this will be a new random value. This value is used as the \"sid\" parameter in the ID Token and in OIDC Front-/Back- channel logout. It's value can generally be used to associate consecutive login requests by a certain user."
  loginSessionId: String

  "OIDCContext contains the OIDC context of the request. If the OAuth 2.0 Authorization request was not an OpenID Connect request, this value will be nil."
  oidcContext: OidcContext

  "RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but might come in handy if you want to deal with additional request parameters."
  requestUrl: String

  "RequestedAccessTokenAudience contains the audience (client) that the OAuth 2.0 Client requested the OAuth 2.0 Access Token to be issued for."
  requestedAccessTokenAudience: [String!]

  "RequestedScope contains the OAuth 2.0 Scope requested by the OAuth 2.0 Client."
  requestedScope: [String!]

  "Skip is true when the client has requested the same scopes from the same user before. If this is true, you can skip asking the user to grant the requested scopes, or you can force showing the UI by setting this value to false."
  skip: Boolean

  "Subject is the user ID of the end-user that authenticated. This value will be set to the \"sub\" claim in the ID Token."
  subject: String!
}

"OIDC Context for a consent request."
type OidcContext {
  "ACRValues is the Authentication AuthorizationContext Class Reference requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses which level of authentication (e.g. 2FA) is required.  OpenID Connect defines it as follows: > Requested Authentication AuthorizationContext Class Reference values. Space-separated string that specifies the acr values that the Authorization Server is being requested to use for processing this Authentication Request, with the values appearing in order of preference. The Authentication AuthorizationContext Class satisfied by the authentication performed is returned as the acr Claim Value, as specified in Section 2. The acr Claim is requested as a Voluntary Claim by this parameter."
  acrValues: [String!]

  "Display is the display mode requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses how the Authorization Server displays authentication and consent user interfaces to the End-User.  OpenID Connect defines it as follows: > ASCII string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User. The defined values are: page: The Authorization Server SHOULD display the authentication and consent UI consistent with a full User Agent page view. If the display parameter is not specified, this is the default display mode. popup: The Authorization Server SHOULD display the authentication and consent UI consistent with a popup User Agent window. The popup User Agent window should be of an appropriate size for a login-focused dialog and should not obscure the entire window that it is popping up over. touch: The Authorization Server SHOULD display the authentication and consent UI consistent with a device that leverages a touch interface. > The display parameter is used only if the prompt parameter value is not none. If the prompt parameter value is none, the display parameter is ignored."
  display: String

  "IDTokenHintClaims contains the claims from the ID Token hint if it was present in the OAuth 2.0 Authorization request."
  idTokenHintClaims: Map

  "LoginHint is the login hint requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses the preferred login identifier the End-User might use to log in (if necessary).  OpenID Connect defines it as follows: > Hint to the Authorization Server about the login identifier the End-User might use to log in (if necessary). > This hint can be used by an RP if it first asks the End-User for their e-mail address (or other identifier) and then wants to pass that value as a hint to the discovered authorization service. > It is RECOMMENDED that the hint value match the value used for discovery. > This value MAY also be a phone number in the format specified for the phone_number Claim. > The use of this parameter is left to the OP's discretion."
  loginHint: String

  "UILocales is the End-User'id preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For instance, the value \"fr-CA fr en\" represents a preference for French as spoken in Canada, then French (without a region designation), followed by English (without a region designation). An error SHOULD NOT result if some or all of the requested locales are not supported by the OpenID Provider."
  uiLocales: [String!]
}

type OAuth2RedirectTo {
  "RedirectTo can be used to redirect the user-agent to a specific location. This is useful if you want to redirect the user-agent to a specific location after the consent flow has been completed."
  redirectTo: String
}

input AcceptOAuth2ConsentRequestSession {
  "AccessToken sets session data for the access and refresh token, as well as any future tokens issued by the refresh grant. Keep in mind that this data will be available to anyone performing OAuth 2.0 Challenge Introspection. If only your services can perform OAuth 2.0 Challenge Introspection, this is usually fine. But if third parties can access that endpoint as well, sensitive data from the session might be exposed to them. Use with care!"
  accessToken: Map

  "IDToken sets session data for the OpenID Connect ID token. Keep in mind that the session'id payloads are readable by anyone that has access to the ID Challenge. Use with care!"
  idToken: Map
}

extend type Query {
  "OAuth2ConsentRequest returns the OAuth 2.0 consent request information."
  oauth2ConsentRequest(
    "The challenge to fetch the consent request for."
    challenge: String!
  ): OAuth2ConsentRequest
}

extend type Mutation {
  "AcceptOAuth2ConsentRequest accepts an OAuth 2.0 consent request. If the request was granted, a code or access token will be issued. If the request was denied, the request will be rejected."
  acceptOAuth2ConsentRequest(
    "The challenge to accept."
    challenge: String!

    "The audience to grant."
    grantAccessTokenAudience: String

    "The scopes to grant."
    grantScope: [String!]

    "Remember, if set to true, tells ORY Hydra to remember this consent authorization and reuse it if the same client asks the same user for the same, or a subset of, scope."
    remember: Boolean

    "RememberFor sets how long the consent authorization should be remembered for in seconds. If set to 0, the authorization will be remembered indefinitely."
    rememberFor: Int

    "The session to set for the granted OAuth 2.0 request."
    session: AcceptOAuth2ConsentRequestSession
  ): OAuth2RedirectTo!

  "RejectOAuth2ConsentRequest rejects an OAuth 2.0 consent request."
  rejectOAuth2ConsentRequest(
    "The challenge to reject."
    challenge: String!
  ): OAuth2RedirectTo!
}
`, BuiltIn: false},
	{Name: "../observabilitytenant.graphqls", Input: `"Representation a tenant in the Grafana observability stack where metrics, logs and traces can be sent to or retrieved from."
type ObservabilityTenant {
  "The unique name of the tenant."
  name: String!

  "The organization that the tenant belongs to."
  organization: Organization!

  "The users that are admins of the organization."
  viewers: ObservabilityTenantViewers

  "The users and groups that can edit a tenant to add users, groups or oauth2 clients to it."
  editors: ObservabilityTenantEditors
}

"Representation of the users, groups and oauth2 clients that can view or send data a tenant."
type ObservabilityTenantViewers {
  "The users that can view a tenant."
  users: [User!]

  "The groups that can view a tenant."
  groups: [Group!]

  "The oauth2 clients that can send data a tenant."
  oauth2Clients: [OAuth2Client!]
}

"Representation of the users and groups that can edit a tenant."
type ObservabilityTenantEditors {
  "The users that can edit a tenant."
  users: [User!]

  "The groups that can edit a tenant."
  groups: [Group!]
}

input ObservabilityTenantViewersInput {
  "The IDs of users that can view a tenant."
  users: [String!]

  "The names of groups that can view a tenant."
  groups: [String!]

  "The clientIDs oauth2 clients that can send data a tenant."
  oauth2Clients: [String!]
}

input ObservabilityTenantEditorsInput {
  "The IDs of users that can edit a tenant."
  users: [String!]

  "The names of groups that can edit a tenant."
  groups: [String!]
}

extend type Query {
  "Get a list of all users."
  listObservabilityTenants: [ObservabilityTenant!]! @checkPermissions @isAuthenticated

  getObservabilityTenant(
    "The name of the tenant."
    name: String!
  ): ObservabilityTenant! @checkPermissions @isAuthenticated
}

extend type Mutation {
  "Create or update an observability tenant."
  observabilityTenant(
    "The name of the tenant."
    name: String!
    "The users, groups or OAuth 2.0 client that have access to the observability tenant."
    viewers: ObservabilityTenantViewersInput
    "The users and groups that can edit a tenant to add users, groups or oauth2 clients to it."
    editors: ObservabilityTenantEditorsInput
  ): ObservabilityTenant! @checkPermissions @isAuthenticated

  "Delete an observability tenant."
  deleteObservabilityTenant(
    "The name of the tenant."
    name: String!
  ): ObservabilityTenant! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
	{Name: "../organization.graphqls", Input: `"Representation an Organization in the auth stack."
type Organization {
  "The unique name of the organization."
  name: String!

  "The users that are admins of the organization."
  admins: [User!]
}

"Input for adding a user to an organization as an administrator."
input Admin {
  "The ID of the user to add as an admin."
  id: ID!
}

extend type Query {
  "Get a list of all users."
  listOrganizations: [Organization!]! @checkPermissions @isAuthenticated
}

extend type Mutation {
  "Create a new organization."
  organization(
    "The name of the organization."
    name: String!,

    "The IDs of the users that are organization admins."
    admins: [String!]!
    ): Organization! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
	{Name: "../user.graphqls", Input: `"Representation of the information about a user sourced from Kratos."
type User {
  "The unique ID of the user."
  id: ID!

  "The user's full name."
  name: Name

  "The user's email address."
  email: String!

  "The groups the user belongs to."
  groups: [Group!]

  "The organization the user belongs to."
  organization: Organization!

  "The link a user can use to recover their account."
  recoveryLink: String
}

"The first and last name of a user."
type Name {
  "The user's first name."
  first: String

  "The user's last name."
  last: String
}

input NameInput {
  "The user's first name."
  first: String

  "The user's last name."
  last: String
}

type Query {
  "Get a list of all users."
  listUsers: [User!]! @checkPermissions @isAuthenticated

  "Get a user by ID."
  getUser(id: ID!): User! @checkPermissions @isAuthenticated
}

type Mutation {
  "Create a new user."
  createUser(
    "The user's email address."
    email: String!
  
    "The user's name."
    name: NameInput

  ): User! @checkPermissions @isAuthenticated

  "Delete a user."
  deleteUser(
    "The ID of the user to delete."
    id: ID!
  ): User! @checkPermissions @isAuthenticated
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_acceptOAuth2ConsentRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["grantAccessTokenAudience"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("grantAccessTokenAudience"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["grantAccessTokenAudience"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["grantScope"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("grantScope"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["grantScope"] = arg2
	var arg3 *bool
	if tmp, ok := rawArgs["remember"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remember"))
		arg3, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["remember"] = arg3
	var arg4 *int64
	if tmp, ok := rawArgs["rememberFor"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rememberFor"))
		arg4, err = ec.unmarshalOInt2int64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rememberFor"] = arg4
	var arg5 *model.AcceptOAuth2ConsentRequestSession
	if tmp, ok := rawArgs["session"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("session"))
		arg5, err = ec.unmarshalOAcceptOAuth2ConsentRequestSession2githubcompluralshoauthplaygroundapiservergraphmodelAcceptOAuth2ConsentRequestSession(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["session"] = arg5
	return args, nil
}

func (ec *executionContext) field_Mutation_createOAuth2Client_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["allowedCorsOrigins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedCorsOrigins"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["allowedCorsOrigins"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["audience"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audience"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["audience"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["authorizationCodeGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantAccessTokenLifespan"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantAccessTokenLifespan"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["authorizationCodeGrantIdTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantIdTokenLifespan"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantIdTokenLifespan"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["authorizationCodeGrantRefreshTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantRefreshTokenLifespan"))
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantRefreshTokenLifespan"] = arg4
	var arg5 *bool
	if tmp, ok := rawArgs["backChannelLogoutSessionRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backChannelLogoutSessionRequired"))
		arg5, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["backChannelLogoutSessionRequired"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["backChannelLogoutUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backChannelLogoutUri"))
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["backChannelLogoutUri"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["clientCredentialsGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientCredentialsGrantAccessTokenLifespan"))
		arg7, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientCredentialsGrantAccessTokenLifespan"] = arg7
	var arg8 *string
	if tmp, ok := rawArgs["clientName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientName"))
		arg8, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientName"] = arg8
	var arg9 *string
	if tmp, ok := rawArgs["clientSecret"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
		arg9, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientSecret"] = arg9
	var arg10 *int64
	if tmp, ok := rawArgs["ClientSecretExpiresAt"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ClientSecretExpiresAt"))
		arg10, err = ec.unmarshalOInt2int64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ClientSecretExpiresAt"] = arg10
	var arg11 *string
	if tmp, ok := rawArgs["clientUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUri"))
		arg11, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientUri"] = arg11
	var arg12 []string
	if tmp, ok := rawArgs["contacts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contacts"))
		arg12, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contacts"] = arg12
	var arg13 *bool
	if tmp, ok := rawArgs["frontchannelLogoutSessionRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frontchannelLogoutSessionRequired"))
		arg13, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frontchannelLogoutSessionRequired"] = arg13
	var arg14 *string
	if tmp, ok := rawArgs["frontchannelLogoutUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frontchannelLogoutUri"))
		arg14, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frontchannelLogoutUri"] = arg14
	var arg15 []string
	if tmp, ok := rawArgs["grantTypes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("grantTypes"))
		arg15, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["grantTypes"] = arg15
	var arg16 *string
	if tmp, ok := rawArgs["implicitGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("implicitGrantAccessTokenLifespan"))
		arg16, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["implicitGrantAccessTokenLifespan"] = arg16
	var arg17 *string
	if tmp, ok := rawArgs["implicitGrantIdTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("implicitGrantIdTokenLifespan"))
		arg17, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["implicitGrantIdTokenLifespan"] = arg17
	var arg18 map[string]interface{}
	if tmp, ok := rawArgs["jwks"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwks"))
		arg18, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwks"] = arg18
	var arg19 *string
	if tmp, ok := rawArgs["jwksUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwksUri"))
		arg19, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwksUri"] = arg19
	var arg20 *string
	if tmp, ok := rawArgs["jwtBearerGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwtBearerGrantAccessTokenLifespan"))
		arg20, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwtBearerGrantAccessTokenLifespan"] = arg20
	var arg21 *string
	if tmp, ok := rawArgs["logoUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logoUri"))
		arg21, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logoUri"] = arg21
	var arg22 map[string]interface{}
	if tmp, ok := rawArgs["metadata"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metadata"))
		arg22, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metadata"] = arg22
	var arg23 *string
	if tmp, ok := rawArgs["policyUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("policyUri"))
		arg23, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["policyUri"] = arg23
	var arg24 []string
	if tmp, ok := rawArgs["postLogoutRedirectUris"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("postLogoutRedirectUris"))
		arg24, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["postLogoutRedirectUris"] = arg24
	var arg25 []string
	if tmp, ok := rawArgs["redirectUris"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectUris"))
		arg25, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["redirectUris"] = arg25
	var arg26 []string
	if tmp, ok := rawArgs["responseTypes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("responseTypes"))
		arg26, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["responseTypes"] = arg26
	var arg27 *string
	if tmp, ok := rawArgs["scope"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scope"))
		arg27, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["scope"] = arg27
	var arg28 *string
	if tmp, ok := rawArgs["sectorIdentifierUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sectorIdentifierUri"))
		arg28, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sectorIdentifierUri"] = arg28
	var arg29 *string
	if tmp, ok := rawArgs["subjectType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subjectType"))
		arg29, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subjectType"] = arg29
	var arg30 *string
	if tmp, ok := rawArgs["tokenEndpointAuthMethod"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointAuthMethod"))
		arg30, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenEndpointAuthMethod"] = arg30
	var arg31 *string
	if tmp, ok := rawArgs["tokenEndpointAuthSigningAlgorithm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointAuthSigningAlgorithm"))
		arg31, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenEndpointAuthSigningAlgorithm"] = arg31
	var arg32 *string
	if tmp, ok := rawArgs["tosUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tosUri"))
		arg32, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tosUri"] = arg32
	var arg33 *string
	if tmp, ok := rawArgs["userinfoSignedResponseAlgorithm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userinfoSignedResponseAlgorithm"))
		arg33, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userinfoSignedResponseAlgorithm"] = arg33
	var arg34 *model.LoginBindingsInput
	if tmp, ok := rawArgs["loginBindings"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginBindings"))
		arg34, err = ec.unmarshalOLoginBindingsInput2githubcompluralshoauthplaygroundapiservergraphmodelLoginBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["loginBindings"] = arg34
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["email"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg0
	var arg1 *model.NameInput
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg1, err = ec.unmarshalONameInput2githubcompluralshoauthplaygroundapiservergraphmodelNameInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteGroup_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteOAuth2Client_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["clientId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteObservabilityTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_group_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["members"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("members"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["members"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_observabilityTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 *model.ObservabilityTenantViewersInput
	if tmp, ok := rawArgs["viewers"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("viewers"))
		arg1, err = ec.unmarshalOObservabilityTenantViewersInput2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenantViewersInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["viewers"] = arg1
	var arg2 *model.ObservabilityTenantEditorsInput
	if tmp, ok := rawArgs["editors"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("editors"))
		arg2, err = ec.unmarshalOObservabilityTenantEditorsInput2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenantEditorsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["editors"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_organization_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["admins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["admins"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_rejectOAuth2ConsentRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateOAuth2Client_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["allowedCorsOrigins"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedCorsOrigins"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["allowedCorsOrigins"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["audience"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("audience"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["audience"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["authorizationCodeGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantAccessTokenLifespan"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantAccessTokenLifespan"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["authorizationCodeGrantIdTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantIdTokenLifespan"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantIdTokenLifespan"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["authorizationCodeGrantRefreshTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizationCodeGrantRefreshTokenLifespan"))
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authorizationCodeGrantRefreshTokenLifespan"] = arg4
	var arg5 *bool
	if tmp, ok := rawArgs["backChannelLogoutSessionRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backChannelLogoutSessionRequired"))
		arg5, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["backChannelLogoutSessionRequired"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["backChannelLogoutUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backChannelLogoutUri"))
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["backChannelLogoutUri"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["clientCredentialsGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientCredentialsGrantAccessTokenLifespan"))
		arg7, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientCredentialsGrantAccessTokenLifespan"] = arg7
	var arg8 string
	if tmp, ok := rawArgs["clientId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
		arg8, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientId"] = arg8
	var arg9 *string
	if tmp, ok := rawArgs["clientName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientName"))
		arg9, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientName"] = arg9
	var arg10 *string
	if tmp, ok := rawArgs["clientSecret"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
		arg10, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientSecret"] = arg10
	var arg11 *int64
	if tmp, ok := rawArgs["ClientSecretExpiresAt"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ClientSecretExpiresAt"))
		arg11, err = ec.unmarshalOInt2int64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ClientSecretExpiresAt"] = arg11
	var arg12 *string
	if tmp, ok := rawArgs["clientUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientUri"))
		arg12, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientUri"] = arg12
	var arg13 []string
	if tmp, ok := rawArgs["contacts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contacts"))
		arg13, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["contacts"] = arg13
	var arg14 *bool
	if tmp, ok := rawArgs["frontchannelLogoutSessionRequired"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frontchannelLogoutSessionRequired"))
		arg14, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frontchannelLogoutSessionRequired"] = arg14
	var arg15 *string
	if tmp, ok := rawArgs["frontchannelLogoutUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("frontchannelLogoutUri"))
		arg15, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["frontchannelLogoutUri"] = arg15
	var arg16 []string
	if tmp, ok := rawArgs["grantTypes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("grantTypes"))
		arg16, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["grantTypes"] = arg16
	var arg17 *string
	if tmp, ok := rawArgs["implicitGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("implicitGrantAccessTokenLifespan"))
		arg17, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["implicitGrantAccessTokenLifespan"] = arg17
	var arg18 *string
	if tmp, ok := rawArgs["implicitGrantIdTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("implicitGrantIdTokenLifespan"))
		arg18, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["implicitGrantIdTokenLifespan"] = arg18
	var arg19 map[string]interface{}
	if tmp, ok := rawArgs["jwks"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwks"))
		arg19, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwks"] = arg19
	var arg20 *string
	if tmp, ok := rawArgs["jwksUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwksUri"))
		arg20, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwksUri"] = arg20
	var arg21 *string
	if tmp, ok := rawArgs["jwtBearerGrantAccessTokenLifespan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwtBearerGrantAccessTokenLifespan"))
		arg21, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["jwtBearerGrantAccessTokenLifespan"] = arg21
	var arg22 *string
	if tmp, ok := rawArgs["logoUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logoUri"))
		arg22, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["logoUri"] = arg22
	var arg23 map[string]interface{}
	if tmp, ok := rawArgs["metadata"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metadata"))
		arg23, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metadata"] = arg23
	var arg24 *string
	if tmp, ok := rawArgs["policyUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("policyUri"))
		arg24, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["policyUri"] = arg24
	var arg25 []string
	if tmp, ok := rawArgs["postLogoutRedirectUris"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("postLogoutRedirectUris"))
		arg25, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["postLogoutRedirectUris"] = arg25
	var arg26 []string
	if tmp, ok := rawArgs["redirectUris"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redirectUris"))
		arg26, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["redirectUris"] = arg26
	var arg27 []string
	if tmp, ok := rawArgs["responseTypes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("responseTypes"))
		arg27, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["responseTypes"] = arg27
	var arg28 *string
	if tmp, ok := rawArgs["scope"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scope"))
		arg28, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["scope"] = arg28
	var arg29 *string
	if tmp, ok := rawArgs["sectorIdentifierUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sectorIdentifierUri"))
		arg29, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sectorIdentifierUri"] = arg29
	var arg30 *string
	if tmp, ok := rawArgs["subjectType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subjectType"))
		arg30, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subjectType"] = arg30
	var arg31 *string
	if tmp, ok := rawArgs["tokenEndpointAuthMethod"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointAuthMethod"))
		arg31, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenEndpointAuthMethod"] = arg31
	var arg32 *string
	if tmp, ok := rawArgs["tokenEndpointAuthSigningAlgorithm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tokenEndpointAuthSigningAlgorithm"))
		arg32, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tokenEndpointAuthSigningAlgorithm"] = arg32
	var arg33 *string
	if tmp, ok := rawArgs["tosUri"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tosUri"))
		arg33, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tosUri"] = arg33
	var arg34 *string
	if tmp, ok := rawArgs["userinfoSignedResponseAlgorithm"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userinfoSignedResponseAlgorithm"))
		arg34, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userinfoSignedResponseAlgorithm"] = arg34
	var arg35 *model.LoginBindingsInput
	if tmp, ok := rawArgs["loginBindings"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginBindings"))
		arg35, err = ec.unmarshalOLoginBindingsInput2githubcompluralshoauthplaygroundapiservergraphmodelLoginBindingsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["loginBindings"] = arg35
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getOAuth2Client_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["clientId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getObservabilityTenant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_oauth2ConsentRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["challenge"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("challenge"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["challenge"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

func (ec *executionContext) _queryMiddleware(ctx context.Context, obj *ast.OperationDefinition, next func(ctx context.Context) (interface{}, error)) graphql.Marshaler {

	for _, d := range obj.Directives {
		switch d.Name {
		case "checkPermissions":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.CheckPermissions == nil {
					return nil, errors.New("directive checkPermissions is not implemented")
				}
				return ec.directives.CheckPermissions(ctx, obj, n)
			}
		case "isAuthenticated":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.IsAuthenticated == nil {
					return nil, errors.New("directive isAuthenticated is not implemented")
				}
				return ec.directives.IsAuthenticated(ctx, obj, n)
			}
		}
	}
	tmp, err := next(ctx)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if data, ok := tmp.(graphql.Marshaler); ok {
		return data
	}
	ec.Errorf(ctx, `unexpected type %T from directive, should be graphql.Marshaler`, tmp)
	return graphql.Null

}

func (ec *executionContext) _mutationMiddleware(ctx context.Context, obj *ast.OperationDefinition, next func(ctx context.Context) (interface{}, error)) graphql.Marshaler {

	for _, d := range obj.Directives {
		switch d.Name {
		case "checkPermissions":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.CheckPermissions == nil {
					return nil, errors.New("directive checkPermissions is not implemented")
				}
				return ec.directives.CheckPermissions(ctx, obj, n)
			}
		case "isAuthenticated":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.IsAuthenticated == nil {
					return nil, errors.New("directive isAuthenticated is not implemented")
				}
				return ec.directives.IsAuthenticated(ctx, obj, n)
			}
		}
	}
	tmp, err := next(ctx)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if data, ok := tmp.(graphql.Marshaler); ok {
		return data
	}
	ec.Errorf(ctx, `unexpected type %T from directive, should be graphql.Marshaler`, tmp)
	return graphql.Null

}

func (ec *executionContext) _fieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) interface{} {
	fc := graphql.GetFieldContext(ctx)
	for _, d := range fc.Field.Directives {
		switch d.Name {
		case "checkPermissions":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.CheckPermissions == nil {
					return nil, errors.New("directive checkPermissions is not implemented")
				}
				return ec.directives.CheckPermissions(ctx, obj, n)
			}
		case "isAuthenticated":
			n := next
			next = func(ctx context.Context) (interface{}, error) {
				if ec.directives.IsAuthenticated == nil {
					return nil, errors.New("directive isAuthenticated is not implemented")
				}
				return ec.directives.IsAuthenticated(ctx, obj, n)
			}
		}
	}
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Group_name(ctx context.Context, field graphql.CollectedField, obj *model.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_members(ctx context.Context, field graphql.CollectedField, obj *model.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_members(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Group().Members(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_members(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "organization":
				return ec.fieldContext_User_organization(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_organization(ctx context.Context, field graphql.CollectedField, obj *model.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organization, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2githubcompluralshoauthplaygroundapiservergraphmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "admins":
				return ec.fieldContext_Organization_admins(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoginBindings_users(ctx context.Context, field graphql.CollectedField, obj *model.LoginBindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoginBindings_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LoginBindings().Users(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoginBindings_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoginBindings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "organization":
				return ec.fieldContext_User_organization(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoginBindings_groups(ctx context.Context, field graphql.CollectedField, obj *model.LoginBindings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoginBindings_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LoginBindings().Groups(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2githubcompluralshoauthplaygroundapiservergraphmodelGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoginBindings_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoginBindings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			case "organization":
				return ec.fieldContext_Group_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["email"].(string), fc.Args["name"].(*model.NameInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.User`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "organization":
				return ec.fieldContext_User_organization(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteUser(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.User`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "organization":
				return ec.fieldContext_User_organization(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_group(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Group(rctx, fc.Args["name"].(string), fc.Args["members"].([]string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Group); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.Group`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Group)
	fc.Result = res
	return ec.marshalNGroup2githubcompluralshoauthplaygroundapiservergraphmodelGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			case "organization":
				return ec.fieldContext_Group_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_group_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGroup(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteGroup(rctx, fc.Args["name"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Group); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.Group`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Group)
	fc.Result = res
	return ec.marshalNGroup2githubcompluralshoauthplaygroundapiservergraphmodelGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			case "organization":
				return ec.fieldContext_Group_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGroup_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createOAuth2Client(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createOAuth2Client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateOAuth2Client(rctx, fc.Args["allowedCorsOrigins"].([]string), fc.Args["audience"].([]string), fc.Args["authorizationCodeGrantAccessTokenLifespan"].(*string), fc.Args["authorizationCodeGrantIdTokenLifespan"].(*string), fc.Args["authorizationCodeGrantRefreshTokenLifespan"].(*string), fc.Args["backChannelLogoutSessionRequired"].(*bool), fc.Args["backChannelLogoutUri"].(*string), fc.Args["clientCredentialsGrantAccessTokenLifespan"].(*string), fc.Args["clientName"].(*string), fc.Args["clientSecret"].(*string), fc.Args["ClientSecretExpiresAt"].(*int64), fc.Args["clientUri"].(*string), fc.Args["contacts"].([]string), fc.Args["frontchannelLogoutSessionRequired"].(*bool), fc.Args["frontchannelLogoutUri"].(*string), fc.Args["grantTypes"].([]string), fc.Args["implicitGrantAccessTokenLifespan"].(*string), fc.Args["implicitGrantIdTokenLifespan"].(*string), fc.Args["jwks"].(map[string]interface{}), fc.Args["jwksUri"].(*string), fc.Args["jwtBearerGrantAccessTokenLifespan"].(*string), fc.Args["logoUri"].(*string), fc.Args["metadata"].(map[string]interface{}), fc.Args["policyUri"].(*string), fc.Args["postLogoutRedirectUris"].([]string), fc.Args["redirectUris"].([]string), fc.Args["responseTypes"].([]string), fc.Args["scope"].(*string), fc.Args["sectorIdentifierUri"].(*string), fc.Args["subjectType"].(*string), fc.Args["tokenEndpointAuthMethod"].(*string), fc.Args["tokenEndpointAuthSigningAlgorithm"].(*string), fc.Args["tosUri"].(*string), fc.Args["userinfoSignedResponseAlgorithm"].(*string), fc.Args["loginBindings"].(*model.LoginBindingsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createOAuth2Client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "organization":
				return ec.fieldContext_OAuth2Client_organization(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createOAuth2Client_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateOAuth2Client(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateOAuth2Client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateOAuth2Client(rctx, fc.Args["allowedCorsOrigins"].([]string), fc.Args["audience"].([]string), fc.Args["authorizationCodeGrantAccessTokenLifespan"].(*string), fc.Args["authorizationCodeGrantIdTokenLifespan"].(*string), fc.Args["authorizationCodeGrantRefreshTokenLifespan"].(*string), fc.Args["backChannelLogoutSessionRequired"].(*bool), fc.Args["backChannelLogoutUri"].(*string), fc.Args["clientCredentialsGrantAccessTokenLifespan"].(*string), fc.Args["clientId"].(string), fc.Args["clientName"].(*string), fc.Args["clientSecret"].(*string), fc.Args["ClientSecretExpiresAt"].(*int64), fc.Args["clientUri"].(*string), fc.Args["contacts"].([]string), fc.Args["frontchannelLogoutSessionRequired"].(*bool), fc.Args["frontchannelLogoutUri"].(*string), fc.Args["grantTypes"].([]string), fc.Args["implicitGrantAccessTokenLifespan"].(*string), fc.Args["implicitGrantIdTokenLifespan"].(*string), fc.Args["jwks"].(map[string]interface{}), fc.Args["jwksUri"].(*string), fc.Args["jwtBearerGrantAccessTokenLifespan"].(*string), fc.Args["logoUri"].(*string), fc.Args["metadata"].(map[string]interface{}), fc.Args["policyUri"].(*string), fc.Args["postLogoutRedirectUris"].([]string), fc.Args["redirectUris"].([]string), fc.Args["responseTypes"].([]string), fc.Args["scope"].(*string), fc.Args["sectorIdentifierUri"].(*string), fc.Args["subjectType"].(*string), fc.Args["tokenEndpointAuthMethod"].(*string), fc.Args["tokenEndpointAuthSigningAlgorithm"].(*string), fc.Args["tosUri"].(*string), fc.Args["userinfoSignedResponseAlgorithm"].(*string), fc.Args["loginBindings"].(*model.LoginBindingsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateOAuth2Client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "organization":
				return ec.fieldContext_OAuth2Client_organization(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateOAuth2Client_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteOAuth2Client(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteOAuth2Client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteOAuth2Client(rctx, fc.Args["clientId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteOAuth2Client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "organization":
				return ec.fieldContext_OAuth2Client_organization(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteOAuth2Client_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_acceptOAuth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_acceptOAuth2ConsentRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AcceptOAuth2ConsentRequest(rctx, fc.Args["challenge"].(string), fc.Args["grantAccessTokenAudience"].(*string), fc.Args["grantScope"].([]string), fc.Args["remember"].(*bool), fc.Args["rememberFor"].(*int64), fc.Args["session"].(*model.AcceptOAuth2ConsentRequestSession))
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2RedirectTo)
	fc.Result = res
	return ec.marshalNOAuth2RedirectTo2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2RedirectTo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_acceptOAuth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "redirectTo":
				return ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2RedirectTo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_acceptOAuth2ConsentRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rejectOAuth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rejectOAuth2ConsentRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RejectOAuth2ConsentRequest(rctx, fc.Args["challenge"].(string))
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2RedirectTo)
	fc.Result = res
	return ec.marshalNOAuth2RedirectTo2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2RedirectTo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rejectOAuth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "redirectTo":
				return ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2RedirectTo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rejectOAuth2ConsentRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_observabilityTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_observabilityTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ObservabilityTenant(rctx, fc.Args["name"].(string), fc.Args["viewers"].(*model.ObservabilityTenantViewersInput), fc.Args["editors"].(*model.ObservabilityTenantEditorsInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_observabilityTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObservabilityTenant_name(ctx, field)
			case "organization":
				return ec.fieldContext_ObservabilityTenant_organization(ctx, field)
			case "viewers":
				return ec.fieldContext_ObservabilityTenant_viewers(ctx, field)
			case "editors":
				return ec.fieldContext_ObservabilityTenant_editors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_observabilityTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteObservabilityTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteObservabilityTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteObservabilityTenant(rctx, fc.Args["name"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteObservabilityTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObservabilityTenant_name(ctx, field)
			case "organization":
				return ec.fieldContext_ObservabilityTenant_organization(ctx, field)
			case "viewers":
				return ec.fieldContext_ObservabilityTenant_viewers(ctx, field)
			case "editors":
				return ec.fieldContext_ObservabilityTenant_editors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteObservabilityTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_organization(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Organization(rctx, fc.Args["name"].(string), fc.Args["admins"].([]string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Organization); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.Organization`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2githubcompluralshoauthplaygroundapiservergraphmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "admins":
				return ec.fieldContext_Organization_admins(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_organization_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Name_first(ctx context.Context, field graphql.CollectedField, obj *model.Name) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Name_first(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.First, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Name_first(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Name",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Name_last(ctx context.Context, field graphql.CollectedField, obj *model.Name) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Name_last(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Last, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Name_last(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Name",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_allowedCorsOrigins(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowedCorsOrigins, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_allowedCorsOrigins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_audience(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_audience(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Audience, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_audience(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizationCodeGrantAccessTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizationCodeGrantIDTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizationCodeGrantRefreshTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_backChannelLogoutSessionRequired(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackChannelLogoutSessionRequired, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_backChannelLogoutUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackChannelLogoutURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_backChannelLogoutUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientCredentialsGrantAccessTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientId(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientID, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientName(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientName, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientSecret(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientSecret, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_ClientSecretExpiresAt(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientSecretExpiresAt, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_clientUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_clientUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_clientUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_contacts(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_contacts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Contacts, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_contacts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_frontchannelLogoutSessionRequired(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FrontchannelLogoutSessionRequired, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_frontchannelLogoutUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FrontchannelLogoutURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_frontchannelLogoutUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_grantTypes(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GrantTypes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_grantTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_implicitGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImplicitGrantAccessTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_implicitGrantIdTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImplicitGrantIDTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_jwks(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_jwks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Jwks, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_jwks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_jwksUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JwksURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_jwksUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JwtBearerGrantAccessTokenLifespan, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_logoUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_logoUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogoURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_logoUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_metadata(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_metadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_owner(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OAuth2Client().Owner(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_policyUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_policyUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PolicyURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_policyUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_postLogoutRedirectUris(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostLogoutRedirectUris, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_postLogoutRedirectUris(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_redirectUris(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedirectUris, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_redirectUris(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_responseTypes(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseTypes, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_responseTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_scope(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_scope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scope, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_scope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_sectorIdentifierUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectorIdentifierURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_sectorIdentifierUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_subjectType(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_subjectType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubjectType, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_subjectType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_tokenEndpointAuthMethod(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenEndpointAuthMethod, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenEndpointAuthSigningAlgorithm, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_tosUri(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_tosUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TosURI, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_tosUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_userinfoSignedResponseAlgorithm(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserinfoSignedResponseAlgorithm, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_organization(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organization, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2githubcompluralshoauthplaygroundapiservergraphmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "admins":
				return ec.fieldContext_Organization_admins(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2Client_loginBindings(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2Client) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OAuth2Client().LoginBindings(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LoginBindings)
	fc.Result = res
	return ec.marshalOLoginBindings2githubcompluralshoauthplaygroundapiservergraphmodelLoginBindings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2Client_loginBindings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2Client",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_LoginBindings_users(ctx, field)
			case "groups":
				return ec.fieldContext_LoginBindings_groups(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoginBindings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_acr(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_acr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Acr, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_acr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_amr(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_amr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amr, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_amr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_challenge(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_challenge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Challenge, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_challenge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_client(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Client, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "organization":
				return ec.fieldContext_OAuth2Client_organization(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_context(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_context(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Context, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_context(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_loginChallenge(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_loginChallenge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoginChallenge, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_loginChallenge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_loginSessionId(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_loginSessionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoginSessionID, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_loginSessionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_oidcContext(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_oidcContext(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OidcContext, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OidcContext)
	fc.Result = res
	return ec.marshalOOidcContext2githubcompluralshoauthplaygroundapiservergraphmodelOidcContext(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_oidcContext(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acrValues":
				return ec.fieldContext_OidcContext_acrValues(ctx, field)
			case "display":
				return ec.fieldContext_OidcContext_display(ctx, field)
			case "idTokenHintClaims":
				return ec.fieldContext_OidcContext_idTokenHintClaims(ctx, field)
			case "loginHint":
				return ec.fieldContext_OidcContext_loginHint(ctx, field)
			case "uiLocales":
				return ec.fieldContext_OidcContext_uiLocales(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OidcContext", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_requestUrl(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_requestUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestURL, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_requestUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_requestedAccessTokenAudience(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_requestedAccessTokenAudience(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestedAccessTokenAudience, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_requestedAccessTokenAudience(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_requestedScope(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_requestedScope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestedScope, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_requestedScope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_skip(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_skip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Skip, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_skip(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2ConsentRequest_subject(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2ConsentRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2ConsentRequest_subject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subject, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2ConsentRequest_subject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2ConsentRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OAuth2RedirectTo_redirectTo(ctx context.Context, field graphql.CollectedField, obj *model.OAuth2RedirectTo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OAuth2RedirectTo_redirectTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedirectTo, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OAuth2RedirectTo_redirectTo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OAuth2RedirectTo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_name(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_organization(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organization, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2githubcompluralshoauthplaygroundapiservergraphmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "admins":
				return ec.fieldContext_Organization_admins(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_viewers(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_viewers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().Viewers(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantViewers)
	fc.Result = res
	return ec.marshalOObservabilityTenantViewers2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenantViewers(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_viewers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantViewers_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantViewers_groups(ctx, field)
			case "oauth2Clients":
				return ec.fieldContext_ObservabilityTenantViewers_oauth2Clients(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantViewers", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenant_editors(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenant_editors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenant().Editors(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenantEditors)
	fc.Result = res
	return ec.marshalOObservabilityTenantEditors2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenantEditors(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenant_editors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenant",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_ObservabilityTenantEditors_users(ctx, field)
			case "groups":
				return ec.fieldContext_ObservabilityTenantEditors_groups(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenantEditors", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantEditors_users(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantEditors) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantEditors_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenantEditors().Users(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantEditors_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantEditors",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "organization":
				return ec.fieldContext_User_organization(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantEditors_groups(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantEditors) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantEditors_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenantEditors().Groups(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2githubcompluralshoauthplaygroundapiservergraphmodelGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantEditors_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantEditors",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			case "organization":
				return ec.fieldContext_Group_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantViewers_users(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantViewers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantViewers_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenantViewers().Users(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantViewers_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantViewers",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "organization":
				return ec.fieldContext_User_organization(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantViewers_groups(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantViewers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantViewers_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenantViewers().Groups(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2githubcompluralshoauthplaygroundapiservergraphmodelGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantViewers_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantViewers",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			case "organization":
				return ec.fieldContext_Group_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObservabilityTenantViewers_oauth2Clients(ctx context.Context, field graphql.CollectedField, obj *model.ObservabilityTenantViewers) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObservabilityTenantViewers_oauth2Clients(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ObservabilityTenantViewers().Oauth2Clients(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.OAuth2Client)
	fc.Result = res
	return ec.marshalOOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObservabilityTenantViewers_oauth2Clients(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObservabilityTenantViewers",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "organization":
				return ec.fieldContext_OAuth2Client_organization(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_acrValues(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_acrValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcrValues, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_acrValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_display(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_display(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Display, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_display(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_idTokenHintClaims(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_idTokenHintClaims(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IDTokenHintClaims, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_idTokenHintClaims(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_loginHint(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_loginHint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoginHint, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_loginHint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OidcContext_uiLocales(ctx context.Context, field graphql.CollectedField, obj *model.OidcContext) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OidcContext_uiLocales(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UILocales, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OidcContext_uiLocales(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OidcContext",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_name(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Organization_admins(ctx context.Context, field graphql.CollectedField, obj *model.Organization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Organization_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Organization().Admins(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalOUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Organization_admins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Organization",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "organization":
				return ec.fieldContext_User_organization(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_listUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListUsers(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/oauth-playground/api-server/graph/model.User`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.User)
	fc.Result = res
	return ec.marshalNUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "organization":
				return ec.fieldContext_User_organization(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetUser(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.User`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "groups":
				return ec.fieldContext_User_groups(ctx, field)
			case "organization":
				return ec.fieldContext_User_organization(ctx, field)
			case "recoveryLink":
				return ec.fieldContext_User_recoveryLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_listGroups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListGroups(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Group); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/oauth-playground/api-server/graph/model.Group`, tmp)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2githubcompluralshoauthplaygroundapiservergraphmodelGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			case "organization":
				return ec.fieldContext_Group_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_listOAuth2Clients(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listOAuth2Clients(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListOAuth2Clients(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/oauth-playground/api-server/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.OAuth2Client)
	fc.Result = res
	return ec.marshalNOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listOAuth2Clients(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "organization":
				return ec.fieldContext_OAuth2Client_organization(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getOAuth2Client(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getOAuth2Client(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetOAuth2Client(rctx, fc.Args["clientId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.OAuth2Client); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.OAuth2Client`, tmp)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2Client)
	fc.Result = res
	return ec.marshalOOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getOAuth2Client(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedCorsOrigins":
				return ec.fieldContext_OAuth2Client_allowedCorsOrigins(ctx, field)
			case "audience":
				return ec.fieldContext_OAuth2Client_audience(ctx, field)
			case "authorizationCodeGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field)
			case "authorizationCodeGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field)
			case "authorizationCodeGrantRefreshTokenLifespan":
				return ec.fieldContext_OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field)
			case "backChannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_backChannelLogoutSessionRequired(ctx, field)
			case "backChannelLogoutUri":
				return ec.fieldContext_OAuth2Client_backChannelLogoutUri(ctx, field)
			case "clientCredentialsGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field)
			case "clientId":
				return ec.fieldContext_OAuth2Client_clientId(ctx, field)
			case "clientName":
				return ec.fieldContext_OAuth2Client_clientName(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OAuth2Client_clientSecret(ctx, field)
			case "ClientSecretExpiresAt":
				return ec.fieldContext_OAuth2Client_ClientSecretExpiresAt(ctx, field)
			case "clientUri":
				return ec.fieldContext_OAuth2Client_clientUri(ctx, field)
			case "contacts":
				return ec.fieldContext_OAuth2Client_contacts(ctx, field)
			case "createdAt":
				return ec.fieldContext_OAuth2Client_createdAt(ctx, field)
			case "frontchannelLogoutSessionRequired":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutSessionRequired(ctx, field)
			case "frontchannelLogoutUri":
				return ec.fieldContext_OAuth2Client_frontchannelLogoutUri(ctx, field)
			case "grantTypes":
				return ec.fieldContext_OAuth2Client_grantTypes(ctx, field)
			case "implicitGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field)
			case "implicitGrantIdTokenLifespan":
				return ec.fieldContext_OAuth2Client_implicitGrantIdTokenLifespan(ctx, field)
			case "jwks":
				return ec.fieldContext_OAuth2Client_jwks(ctx, field)
			case "jwksUri":
				return ec.fieldContext_OAuth2Client_jwksUri(ctx, field)
			case "jwtBearerGrantAccessTokenLifespan":
				return ec.fieldContext_OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field)
			case "logoUri":
				return ec.fieldContext_OAuth2Client_logoUri(ctx, field)
			case "metadata":
				return ec.fieldContext_OAuth2Client_metadata(ctx, field)
			case "owner":
				return ec.fieldContext_OAuth2Client_owner(ctx, field)
			case "policyUri":
				return ec.fieldContext_OAuth2Client_policyUri(ctx, field)
			case "postLogoutRedirectUris":
				return ec.fieldContext_OAuth2Client_postLogoutRedirectUris(ctx, field)
			case "redirectUris":
				return ec.fieldContext_OAuth2Client_redirectUris(ctx, field)
			case "responseTypes":
				return ec.fieldContext_OAuth2Client_responseTypes(ctx, field)
			case "scope":
				return ec.fieldContext_OAuth2Client_scope(ctx, field)
			case "sectorIdentifierUri":
				return ec.fieldContext_OAuth2Client_sectorIdentifierUri(ctx, field)
			case "subjectType":
				return ec.fieldContext_OAuth2Client_subjectType(ctx, field)
			case "tokenEndpointAuthMethod":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthMethod(ctx, field)
			case "tokenEndpointAuthSigningAlgorithm":
				return ec.fieldContext_OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field)
			case "tosUri":
				return ec.fieldContext_OAuth2Client_tosUri(ctx, field)
			case "updatedAt":
				return ec.fieldContext_OAuth2Client_updatedAt(ctx, field)
			case "userinfoSignedResponseAlgorithm":
				return ec.fieldContext_OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field)
			case "organization":
				return ec.fieldContext_OAuth2Client_organization(ctx, field)
			case "loginBindings":
				return ec.fieldContext_OAuth2Client_loginBindings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2Client", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getOAuth2Client_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_oauth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_oauth2ConsentRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Oauth2ConsentRequest(rctx, fc.Args["challenge"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.OAuth2ConsentRequest)
	fc.Result = res
	return ec.marshalOOAuth2ConsentRequest2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2ConsentRequest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_oauth2ConsentRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acr":
				return ec.fieldContext_OAuth2ConsentRequest_acr(ctx, field)
			case "amr":
				return ec.fieldContext_OAuth2ConsentRequest_amr(ctx, field)
			case "challenge":
				return ec.fieldContext_OAuth2ConsentRequest_challenge(ctx, field)
			case "client":
				return ec.fieldContext_OAuth2ConsentRequest_client(ctx, field)
			case "context":
				return ec.fieldContext_OAuth2ConsentRequest_context(ctx, field)
			case "loginChallenge":
				return ec.fieldContext_OAuth2ConsentRequest_loginChallenge(ctx, field)
			case "loginSessionId":
				return ec.fieldContext_OAuth2ConsentRequest_loginSessionId(ctx, field)
			case "oidcContext":
				return ec.fieldContext_OAuth2ConsentRequest_oidcContext(ctx, field)
			case "requestUrl":
				return ec.fieldContext_OAuth2ConsentRequest_requestUrl(ctx, field)
			case "requestedAccessTokenAudience":
				return ec.fieldContext_OAuth2ConsentRequest_requestedAccessTokenAudience(ctx, field)
			case "requestedScope":
				return ec.fieldContext_OAuth2ConsentRequest_requestedScope(ctx, field)
			case "skip":
				return ec.fieldContext_OAuth2ConsentRequest_skip(ctx, field)
			case "subject":
				return ec.fieldContext_OAuth2ConsentRequest_subject(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OAuth2ConsentRequest", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_oauth2ConsentRequest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_listObservabilityTenants(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listObservabilityTenants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListObservabilityTenants(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/oauth-playground/api-server/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listObservabilityTenants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObservabilityTenant_name(ctx, field)
			case "organization":
				return ec.fieldContext_ObservabilityTenant_organization(ctx, field)
			case "viewers":
				return ec.fieldContext_ObservabilityTenant_viewers(ctx, field)
			case "editors":
				return ec.fieldContext_ObservabilityTenant_editors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getObservabilityTenant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getObservabilityTenant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetObservabilityTenant(rctx, fc.Args["name"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ObservabilityTenant); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/pluralsh/oauth-playground/api-server/graph/model.ObservabilityTenant`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ObservabilityTenant)
	fc.Result = res
	return ec.marshalNObservabilityTenant2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getObservabilityTenant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ObservabilityTenant_name(ctx, field)
			case "organization":
				return ec.fieldContext_ObservabilityTenant_organization(ctx, field)
			case "viewers":
				return ec.fieldContext_ObservabilityTenant_viewers(ctx, field)
			case "editors":
				return ec.fieldContext_ObservabilityTenant_editors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObservabilityTenant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getObservabilityTenant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_listOrganizations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listOrganizations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListOrganizations(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.CheckPermissions == nil {
				return nil, errors.New("directive checkPermissions is not implemented")
			}
			return ec.directives.CheckPermissions(ctx, nil, directive0)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsAuthenticated == nil {
				return nil, errors.New("directive isAuthenticated is not implemented")
			}
			return ec.directives.IsAuthenticated(ctx, nil, directive1)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.Organization); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/pluralsh/oauth-playground/api-server/graph/model.Organization`, tmp)
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2githubcompluralshoauthplaygroundapiservergraphmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listOrganizations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "admins":
				return ec.fieldContext_Organization_admins(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Name)
	fc.Result = res
	return ec.marshalOName2githubcompluralshoauthplaygroundapiservergraphmodelName(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "first":
				return ec.fieldContext_Name_first(ctx, field)
			case "last":
				return ec.fieldContext_Name_last(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Name", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_groups(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Groups(rctx, obj)
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Group)
	fc.Result = res
	return ec.marshalOGroup2githubcompluralshoauthplaygroundapiservergraphmodelGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "members":
				return ec.fieldContext_Group_members(ctx, field)
			case "organization":
				return ec.fieldContext_Group_organization(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_organization(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Organization, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Organization)
	fc.Result = res
	return ec.marshalNOrganization2githubcompluralshoauthplaygroundapiservergraphmodelOrganization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_organization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Organization_name(ctx, field)
			case "admins":
				return ec.fieldContext_Organization_admins(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Organization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_recoveryLink(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_recoveryLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecoveryLink, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_recoveryLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})

	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp := ec._fieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})

	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAcceptOAuth2ConsentRequestSession(ctx context.Context, obj interface{}) (model.AcceptOAuth2ConsentRequestSession, error) {
	var it model.AcceptOAuth2ConsentRequestSession
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"accessToken", "idToken"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "accessToken":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessToken"))
			it.AccessToken, err = ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "idToken":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idToken"))
			it.IDToken, err = ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAdmin(ctx context.Context, obj interface{}) (model.Admin, error) {
	var it model.Admin
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoginBindingsInput(ctx context.Context, obj interface{}) (model.LoginBindingsInput, error) {
	var it model.LoginBindingsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"users", "groups"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "users":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("users"))
			it.Users, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groups"))
			it.Groups, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNameInput(ctx context.Context, obj interface{}) (model.NameInput, error) {
	var it model.NameInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"first", "last"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "first":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
			it.First, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "last":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
			it.Last, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputObservabilityTenantEditorsInput(ctx context.Context, obj interface{}) (model.ObservabilityTenantEditorsInput, error) {
	var it model.ObservabilityTenantEditorsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"users", "groups"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "users":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("users"))
			it.Users, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groups"))
			it.Groups, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputObservabilityTenantViewersInput(ctx context.Context, obj interface{}) (model.ObservabilityTenantViewersInput, error) {
	var it model.ObservabilityTenantViewersInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"users", "groups", "oauth2Clients"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "users":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("users"))
			it.Users, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groups"))
			it.Groups, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "oauth2Clients":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oauth2Clients"))
			it.Oauth2Clients, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var groupImplementors = []string{"Group"}

func (ec *executionContext) _Group(ctx context.Context, sel ast.SelectionSet, obj *model.Group) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Group")
		case "name":

			out.Values[i] = ec._Group_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "members":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Group_members(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "organization":

			out.Values[i] = ec._Group_organization(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loginBindingsImplementors = []string{"LoginBindings"}

func (ec *executionContext) _LoginBindings(ctx context.Context, sel ast.SelectionSet, obj *model.LoginBindings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loginBindingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoginBindings")
		case "users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoginBindings_users(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "groups":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LoginBindings_groups(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})

		case "deleteUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteUser(ctx, field)
			})

		case "group":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_group(ctx, field)
			})

		case "deleteGroup":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGroup(ctx, field)
			})

		case "createOAuth2Client":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createOAuth2Client(ctx, field)
			})

		case "updateOAuth2Client":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateOAuth2Client(ctx, field)
			})

		case "deleteOAuth2Client":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteOAuth2Client(ctx, field)
			})

		case "acceptOAuth2ConsentRequest":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_acceptOAuth2ConsentRequest(ctx, field)
			})

		case "rejectOAuth2ConsentRequest":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rejectOAuth2ConsentRequest(ctx, field)
			})

		case "observabilityTenant":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_observabilityTenant(ctx, field)
			})

		case "deleteObservabilityTenant":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteObservabilityTenant(ctx, field)
			})

		case "organization":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_organization(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	return out
}

var nameImplementors = []string{"Name"}

func (ec *executionContext) _Name(ctx context.Context, sel ast.SelectionSet, obj *model.Name) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nameImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Name")
		case "first":

			out.Values[i] = ec._Name_first(ctx, field, obj)

		case "last":

			out.Values[i] = ec._Name_last(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var oAuth2ClientImplementors = []string{"OAuth2Client"}

func (ec *executionContext) _OAuth2Client(ctx context.Context, sel ast.SelectionSet, obj *model.OAuth2Client) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuth2ClientImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuth2Client")
		case "allowedCorsOrigins":

			out.Values[i] = ec._OAuth2Client_allowedCorsOrigins(ctx, field, obj)

		case "audience":

			out.Values[i] = ec._OAuth2Client_audience(ctx, field, obj)

		case "authorizationCodeGrantAccessTokenLifespan":

			out.Values[i] = ec._OAuth2Client_authorizationCodeGrantAccessTokenLifespan(ctx, field, obj)

		case "authorizationCodeGrantIdTokenLifespan":

			out.Values[i] = ec._OAuth2Client_authorizationCodeGrantIdTokenLifespan(ctx, field, obj)

		case "authorizationCodeGrantRefreshTokenLifespan":

			out.Values[i] = ec._OAuth2Client_authorizationCodeGrantRefreshTokenLifespan(ctx, field, obj)

		case "backChannelLogoutSessionRequired":

			out.Values[i] = ec._OAuth2Client_backChannelLogoutSessionRequired(ctx, field, obj)

		case "backChannelLogoutUri":

			out.Values[i] = ec._OAuth2Client_backChannelLogoutUri(ctx, field, obj)

		case "clientCredentialsGrantAccessTokenLifespan":

			out.Values[i] = ec._OAuth2Client_clientCredentialsGrantAccessTokenLifespan(ctx, field, obj)

		case "clientId":

			out.Values[i] = ec._OAuth2Client_clientId(ctx, field, obj)

		case "clientName":

			out.Values[i] = ec._OAuth2Client_clientName(ctx, field, obj)

		case "clientSecret":

			out.Values[i] = ec._OAuth2Client_clientSecret(ctx, field, obj)

		case "ClientSecretExpiresAt":

			out.Values[i] = ec._OAuth2Client_ClientSecretExpiresAt(ctx, field, obj)

		case "clientUri":

			out.Values[i] = ec._OAuth2Client_clientUri(ctx, field, obj)

		case "contacts":

			out.Values[i] = ec._OAuth2Client_contacts(ctx, field, obj)

		case "createdAt":

			out.Values[i] = ec._OAuth2Client_createdAt(ctx, field, obj)

		case "frontchannelLogoutSessionRequired":

			out.Values[i] = ec._OAuth2Client_frontchannelLogoutSessionRequired(ctx, field, obj)

		case "frontchannelLogoutUri":

			out.Values[i] = ec._OAuth2Client_frontchannelLogoutUri(ctx, field, obj)

		case "grantTypes":

			out.Values[i] = ec._OAuth2Client_grantTypes(ctx, field, obj)

		case "implicitGrantAccessTokenLifespan":

			out.Values[i] = ec._OAuth2Client_implicitGrantAccessTokenLifespan(ctx, field, obj)

		case "implicitGrantIdTokenLifespan":

			out.Values[i] = ec._OAuth2Client_implicitGrantIdTokenLifespan(ctx, field, obj)

		case "jwks":

			out.Values[i] = ec._OAuth2Client_jwks(ctx, field, obj)

		case "jwksUri":

			out.Values[i] = ec._OAuth2Client_jwksUri(ctx, field, obj)

		case "jwtBearerGrantAccessTokenLifespan":

			out.Values[i] = ec._OAuth2Client_jwtBearerGrantAccessTokenLifespan(ctx, field, obj)

		case "logoUri":

			out.Values[i] = ec._OAuth2Client_logoUri(ctx, field, obj)

		case "metadata":

			out.Values[i] = ec._OAuth2Client_metadata(ctx, field, obj)

		case "owner":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OAuth2Client_owner(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "policyUri":

			out.Values[i] = ec._OAuth2Client_policyUri(ctx, field, obj)

		case "postLogoutRedirectUris":

			out.Values[i] = ec._OAuth2Client_postLogoutRedirectUris(ctx, field, obj)

		case "redirectUris":

			out.Values[i] = ec._OAuth2Client_redirectUris(ctx, field, obj)

		case "responseTypes":

			out.Values[i] = ec._OAuth2Client_responseTypes(ctx, field, obj)

		case "scope":

			out.Values[i] = ec._OAuth2Client_scope(ctx, field, obj)

		case "sectorIdentifierUri":

			out.Values[i] = ec._OAuth2Client_sectorIdentifierUri(ctx, field, obj)

		case "subjectType":

			out.Values[i] = ec._OAuth2Client_subjectType(ctx, field, obj)

		case "tokenEndpointAuthMethod":

			out.Values[i] = ec._OAuth2Client_tokenEndpointAuthMethod(ctx, field, obj)

		case "tokenEndpointAuthSigningAlgorithm":

			out.Values[i] = ec._OAuth2Client_tokenEndpointAuthSigningAlgorithm(ctx, field, obj)

		case "tosUri":

			out.Values[i] = ec._OAuth2Client_tosUri(ctx, field, obj)

		case "updatedAt":

			out.Values[i] = ec._OAuth2Client_updatedAt(ctx, field, obj)

		case "userinfoSignedResponseAlgorithm":

			out.Values[i] = ec._OAuth2Client_userinfoSignedResponseAlgorithm(ctx, field, obj)

		case "organization":

			out.Values[i] = ec._OAuth2Client_organization(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "loginBindings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OAuth2Client_loginBindings(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var oAuth2ConsentRequestImplementors = []string{"OAuth2ConsentRequest"}

func (ec *executionContext) _OAuth2ConsentRequest(ctx context.Context, sel ast.SelectionSet, obj *model.OAuth2ConsentRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuth2ConsentRequestImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuth2ConsentRequest")
		case "acr":

			out.Values[i] = ec._OAuth2ConsentRequest_acr(ctx, field, obj)

		case "amr":

			out.Values[i] = ec._OAuth2ConsentRequest_amr(ctx, field, obj)

		case "challenge":

			out.Values[i] = ec._OAuth2ConsentRequest_challenge(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "client":

			out.Values[i] = ec._OAuth2ConsentRequest_client(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "context":

			out.Values[i] = ec._OAuth2ConsentRequest_context(ctx, field, obj)

		case "loginChallenge":

			out.Values[i] = ec._OAuth2ConsentRequest_loginChallenge(ctx, field, obj)

		case "loginSessionId":

			out.Values[i] = ec._OAuth2ConsentRequest_loginSessionId(ctx, field, obj)

		case "oidcContext":

			out.Values[i] = ec._OAuth2ConsentRequest_oidcContext(ctx, field, obj)

		case "requestUrl":

			out.Values[i] = ec._OAuth2ConsentRequest_requestUrl(ctx, field, obj)

		case "requestedAccessTokenAudience":

			out.Values[i] = ec._OAuth2ConsentRequest_requestedAccessTokenAudience(ctx, field, obj)

		case "requestedScope":

			out.Values[i] = ec._OAuth2ConsentRequest_requestedScope(ctx, field, obj)

		case "skip":

			out.Values[i] = ec._OAuth2ConsentRequest_skip(ctx, field, obj)

		case "subject":

			out.Values[i] = ec._OAuth2ConsentRequest_subject(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var oAuth2RedirectToImplementors = []string{"OAuth2RedirectTo"}

func (ec *executionContext) _OAuth2RedirectTo(ctx context.Context, sel ast.SelectionSet, obj *model.OAuth2RedirectTo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oAuth2RedirectToImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuth2RedirectTo")
		case "redirectTo":

			out.Values[i] = ec._OAuth2RedirectTo_redirectTo(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var observabilityTenantImplementors = []string{"ObservabilityTenant"}

func (ec *executionContext) _ObservabilityTenant(ctx context.Context, sel ast.SelectionSet, obj *model.ObservabilityTenant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, observabilityTenantImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObservabilityTenant")
		case "name":

			out.Values[i] = ec._ObservabilityTenant_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "organization":

			out.Values[i] = ec._ObservabilityTenant_organization(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "viewers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_viewers(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "editors":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenant_editors(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var observabilityTenantEditorsImplementors = []string{"ObservabilityTenantEditors"}

func (ec *executionContext) _ObservabilityTenantEditors(ctx context.Context, sel ast.SelectionSet, obj *model.ObservabilityTenantEditors) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, observabilityTenantEditorsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObservabilityTenantEditors")
		case "users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenantEditors_users(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "groups":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenantEditors_groups(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var observabilityTenantViewersImplementors = []string{"ObservabilityTenantViewers"}

func (ec *executionContext) _ObservabilityTenantViewers(ctx context.Context, sel ast.SelectionSet, obj *model.ObservabilityTenantViewers) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, observabilityTenantViewersImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObservabilityTenantViewers")
		case "users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenantViewers_users(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "groups":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenantViewers_groups(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "oauth2Clients":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ObservabilityTenantViewers_oauth2Clients(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var oidcContextImplementors = []string{"OidcContext"}

func (ec *executionContext) _OidcContext(ctx context.Context, sel ast.SelectionSet, obj *model.OidcContext) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oidcContextImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OidcContext")
		case "acrValues":

			out.Values[i] = ec._OidcContext_acrValues(ctx, field, obj)

		case "display":

			out.Values[i] = ec._OidcContext_display(ctx, field, obj)

		case "idTokenHintClaims":

			out.Values[i] = ec._OidcContext_idTokenHintClaims(ctx, field, obj)

		case "loginHint":

			out.Values[i] = ec._OidcContext_loginHint(ctx, field, obj)

		case "uiLocales":

			out.Values[i] = ec._OidcContext_uiLocales(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var organizationImplementors = []string{"Organization"}

func (ec *executionContext) _Organization(ctx context.Context, sel ast.SelectionSet, obj *model.Organization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, organizationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Organization")
		case "name":

			out.Values[i] = ec._Organization_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "admins":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Organization_admins(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "listUsers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listUsers(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUser(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "listGroups":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listGroups(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "listOAuth2Clients":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listOAuth2Clients(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getOAuth2Client":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getOAuth2Client(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "oauth2ConsentRequest":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_oauth2ConsentRequest(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "listObservabilityTenants":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listObservabilityTenants(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getObservabilityTenant":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getObservabilityTenant(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "listOrganizations":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listOrganizations(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":

			out.Values[i] = ec._User_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._User_name(ctx, field, obj)

		case "email":

			out.Values[i] = ec._User_email(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "groups":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_groups(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "organization":

			out.Values[i] = ec._User_organization(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "recoveryLink":

			out.Values[i] = ec._User_recoveryLink(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNGroup2githubcompluralshoauthplaygroundapiservergraphmodelGroup(ctx context.Context, sel ast.SelectionSet, v model.Group) graphql.Marshaler {
	return ec._Group(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroup2githubcompluralshoauthplaygroundapiservergraphmodelGroup(ctx context.Context, sel ast.SelectionSet, v *model.Group) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Group(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx context.Context, sel ast.SelectionSet, v model.OAuth2Client) graphql.Marshaler {
	return ec._OAuth2Client(ctx, sel, &v)
}

func (ec *executionContext) marshalNOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx context.Context, sel ast.SelectionSet, v []*model.OAuth2Client) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2Client) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OAuth2Client(ctx, sel, v)
}

func (ec *executionContext) marshalNOAuth2RedirectTo2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2RedirectTo(ctx context.Context, sel ast.SelectionSet, v model.OAuth2RedirectTo) graphql.Marshaler {
	return ec._OAuth2RedirectTo(ctx, sel, &v)
}

func (ec *executionContext) marshalNOAuth2RedirectTo2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2RedirectTo(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2RedirectTo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OAuth2RedirectTo(ctx, sel, v)
}

func (ec *executionContext) marshalNObservabilityTenant2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenant(ctx context.Context, sel ast.SelectionSet, v model.ObservabilityTenant) graphql.Marshaler {
	return ec._ObservabilityTenant(ctx, sel, &v)
}

func (ec *executionContext) marshalNObservabilityTenant2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenant(ctx context.Context, sel ast.SelectionSet, v []*model.ObservabilityTenant) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNObservabilityTenant2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNObservabilityTenant2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenant(ctx context.Context, sel ast.SelectionSet, v *model.ObservabilityTenant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ObservabilityTenant(ctx, sel, v)
}

func (ec *executionContext) marshalNOrganization2githubcompluralshoauthplaygroundapiservergraphmodelOrganization(ctx context.Context, sel ast.SelectionSet, v model.Organization) graphql.Marshaler {
	return ec._Organization(ctx, sel, &v)
}

func (ec *executionContext) marshalNOrganization2githubcompluralshoauthplaygroundapiservergraphmodelOrganization(ctx context.Context, sel ast.SelectionSet, v []*model.Organization) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOrganization2githubcompluralshoauthplaygroundapiservergraphmodelOrganization(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOrganization2githubcompluralshoauthplaygroundapiservergraphmodelOrganization(ctx context.Context, sel ast.SelectionSet, v *model.Organization) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Organization(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx context.Context, sel ast.SelectionSet, v model.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx context.Context, sel ast.SelectionSet, v []*model.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAcceptOAuth2ConsentRequestSession2githubcompluralshoauthplaygroundapiservergraphmodelAcceptOAuth2ConsentRequestSession(ctx context.Context, v interface{}) (*model.AcceptOAuth2ConsentRequestSession, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAcceptOAuth2ConsentRequestSession(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOGroup2githubcompluralshoauthplaygroundapiservergraphmodelGroup(ctx context.Context, sel ast.SelectionSet, v []*model.Group) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroup2githubcompluralshoauthplaygroundapiservergraphmodelGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) marshalOLoginBindings2githubcompluralshoauthplaygroundapiservergraphmodelLoginBindings(ctx context.Context, sel ast.SelectionSet, v *model.LoginBindings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoginBindings(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLoginBindingsInput2githubcompluralshoauthplaygroundapiservergraphmodelLoginBindingsInput(ctx context.Context, v interface{}) (*model.LoginBindingsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoginBindingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) marshalOName2githubcompluralshoauthplaygroundapiservergraphmodelName(ctx context.Context, sel ast.SelectionSet, v *model.Name) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Name(ctx, sel, v)
}

func (ec *executionContext) unmarshalONameInput2githubcompluralshoauthplaygroundapiservergraphmodelNameInput(ctx context.Context, v interface{}) (*model.NameInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNameInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx context.Context, sel ast.SelectionSet, v []*model.OAuth2Client) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOOAuth2Client2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2Client(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2Client) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OAuth2Client(ctx, sel, v)
}

func (ec *executionContext) marshalOOAuth2ConsentRequest2githubcompluralshoauthplaygroundapiservergraphmodelOAuth2ConsentRequest(ctx context.Context, sel ast.SelectionSet, v *model.OAuth2ConsentRequest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OAuth2ConsentRequest(ctx, sel, v)
}

func (ec *executionContext) marshalOObservabilityTenantEditors2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenantEditors(ctx context.Context, sel ast.SelectionSet, v *model.ObservabilityTenantEditors) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ObservabilityTenantEditors(ctx, sel, v)
}

func (ec *executionContext) unmarshalOObservabilityTenantEditorsInput2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenantEditorsInput(ctx context.Context, v interface{}) (*model.ObservabilityTenantEditorsInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputObservabilityTenantEditorsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOObservabilityTenantViewers2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenantViewers(ctx context.Context, sel ast.SelectionSet, v *model.ObservabilityTenantViewers) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ObservabilityTenantViewers(ctx, sel, v)
}

func (ec *executionContext) unmarshalOObservabilityTenantViewersInput2githubcompluralshoauthplaygroundapiservergraphmodelObservabilityTenantViewersInput(ctx context.Context, v interface{}) (*model.ObservabilityTenantViewersInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputObservabilityTenantViewersInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOidcContext2githubcompluralshoauthplaygroundapiservergraphmodelOidcContext(ctx context.Context, sel ast.SelectionSet, v *model.OidcContext) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OidcContext(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx context.Context, sel ast.SelectionSet, v []*model.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2githubcompluralshoauthplaygroundapiservergraphmodelUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
